<link rel="import" href="../iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../deko-card-container/deko-card-container.html">
<link rel="import" href="../iron-media-query/iron-media-query.html">
<link rel="import" href="../deko-opened-card/deko-opened-card.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../image-base64/image-base64.html">
<link rel="import" href="../icon-icons/editor-icons.html">
<link rel="import" href="../icon-icons/places-icons.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../input-image/input-image.html">
<link rel="import" href="../deko-card/deko-card.html">
<link rel="import" href="../open-card/open-card.html">
<link rel="import" href="../quill-js/quill-js.html">
<link rel="import" href="../q-card/q-card.html">
<dom-module id="deko-cards">
  <template>
    <style>
      :root {
        --paper-chip-background-color:red;
        --paper-chip-secondary-text-color:#fff;
      }
      #narrow {
        @apply(--layout-horizontal);
        @apply(--layout-center-justified);
        height: 100%;
      }
      paper-button {
        color: #fff;
        padding: 5px;
      }
      #card-view {
        @apply(--layout-horizontal);
        @apply(--layout-center-justified);
        @apply(--layout-wrap);
      }
      deko-card-container {
        margin-top: 50px;
      }
      .pre.desktop {
        left: 80px;
      }
      .nex.desktop {
        right: 80px;
      }
      .desktop {
        position: absolute;
        top: 320px;
      }
      .nex.mobile {
        position: absolute;
        left: 200px;
        bottom: -45px;
      }
      .pre.mobile {
        position: absolute;
        left: 200px;
        bottom: -25px;
      }
      .mobile {
        transform: rotate(90deg);   
      }
      paper-toolbar {
        --paper-toolbar-height: 35px;
        --paper-toolbar-sm-height: 35px;
        --paper-toolbar-title: {
          font-size: 18px;
          font-weight: 300;
        }
      }
      *, *:before, *:after {
        box-sizing: border-box; 
      }
      /* make a grid */
      #narrow .wrapper {
        max-width: 700px;
        margin: 0 auto;
        display: grid;
        grid-gap: 1px;
      }
      .title {
        margin-left: none;
      }
    </style>
    <app-route route="{{route}}" pattern="/:data" data="{{routeData}}" tail="{{tail}}"></app-route>
    <iron-media-query query="(min-width: 700px)" query-matches="{{wide}}"></iron-media-query>
    <!--Wide Layout for Desktop-->
    <template is="dom-if" if="{{wide}}">
      <template is="dom-if" if="[[pageing]]" restamp>
        <paper-input label="Start At ..." value="{{find}}"></paper-input>
      </template>
      <div id="card-view">
        <div class="pre desktop">
          <template is="dom-if" if="[[pagesLength]]">
            <paper-button on-tap="perv"><h6>&lt;</h6></paper-button>
          </template>
        </div>
        <deko-card-container>
          <template is="dom-repeat" items="{{items}}" initial-Count="1" id="list0">
            <deko-card on-tap="selectOpen" card="[[item]]"></deko-card>
          </template>
        </deko-card-container>
        <div class="nex desktop">
          <template is="dom-if" if="[[nextPageStartAt]]">
            <paper-button on-tap="next"><h6>></h6> </paper-button>
          </template>
        </div>
      </div>
    </template>
    <!--Narrow Layout under 700px-->
    <template is="dom-if" if="{{!wide}}">
      <template is="dom-if" if="[[pageing]]" restamp>
        <paper-input label="Start At ..." value="{{find}}"></paper-input>
      </template>
      <div style="height: 100%">
        <div class="pre mobile">
          <template is="dom-if" if="[[pagesLength]]">
            <paper-button on-tap="perv"><h6>&lt;</h6></paper-button>
          </template>
        </div>
        <template is="dom-repeat" items="{{items}}" filter="pickable"  id="list1">
          <paper-toolbar class="toolbarMobile" on-tap="select" title="[[item.title]]" card="{{item}}" style$="background:[[item.toolbarColor]]; height: 35px;">
            <iron-icon icon="[[item.icon]]" style="height:90%"></iron-icon>
            <div class="title">[[item.title]]</div>
          </paper-toolbar>
        </template>
        <template is="dom-repeat" items="{{items}}" filter="selected" id="list4">
          <div id="narrow">
            <deko-card on-tap="selectOpen" card="{{item}}"></deko-card>
          </div>
        </template>
        <div class="nex mobile">
          <template is="dom-if" if="[[nextPageStartAt]]">
            <paper-button on-tap="next"><h6>></h6> </paper-button>
          </template>
        </div>
      </div>
    </template>
    <template is="dom-repeat" items="{{items}}" filter="selected"  id="list5">
      <open-card svg="/images/deko.svg" on-touchstart="noDrag" prompt="[[prompt]]" on-chip="addTextSetPrompt" chips="[[chips]]" other-chips="[[commands]]" icons='[[cardIcons]]' on-mousedown="noDrag" selected="{{cardPart}}" on-cancel="deleteCard" on-done="resub" on-new="new">
        <div style="margin: auto;width: 500px;">
          <template is="dom-if" if="[[item.image]]">  
            <paper-toolbar style$="background:[[item.toolbarColor]];color:[[getFg(item.toolbarColor)]]"></paper-toolbar>
            <div style$="background:url([[item.image]]);width:500px;height:200px;background-size: cover;background-position: center;"></div>
          </template>
          <quill-js style="max-width: 500px;margin: auto;" value="{{item.quill}}" one-way id="editor" no-resize editor="{{quill}}" theme="bubble" ></quill-js>
          <q-card part="[[cardPart]]" line="[[line]]" editor="[[quill]]" meta="[[meta]]" tricks="[[tricks]]" card="{{item}}" prompt="{{prompt}}" chips="{{chips}}"></q-card>
        </div>
        <div style="margin: auto;width: 500px;">
          <template is="dom-if" if="[[item.image]]">
            <paper-toolbar style$="background:[[item.toolbarColor]];color:[[getFg(item.toolbarColor)]]"></paper-toolbar>
            <div style$="background:url([[item.image]]);width:500px;height:200px;background-size: cover;background-position: center;"></div>
          </template>
          <quill-js value="[[item.quill]]" id="show" show editor-show="{{showQuill}}" style="max-width: 500px;margin: auto;" ></quill-js>
        </div>
      </open-card>
    </template>
    <!-- <image-base64 url="[[selectedItem.image]]" max-height="200" max-width="200" base64="{{addingImage}}"></image-base64>
    -->
    <div style="max-width: 500px">
      <div style="position: fixed;bottom: 90px;justify-content: space-evenly;flex: auto;width: 98%;display: flex;">
        <template is="dom-repeat" items="[[tableCommands]]">
          <paper-chip on-tap="fireChip" single-line value="[[index]]" style="z-index: 400;">
            <div class="label">[[item]]</div>
          </paper-chip>
        </template>
      </div>
    </div>
    <img on-tap="new" style="position: fixed;bottom: 17px;margin-left: -30px;left: 50%;height: 60px;cursor:pointer;" src="/images/deko.svg" autofocus/>
  </template>
</dom-module>
<script>
  Polymer({
    is: "deko-cards",
    properties:{
      _setItems:{
        computed: "setItems(cards, byChild, loadNum, startAt, wide)",
      },
      end:{value: 999},
      find:{value: ""},
      deck:{value: ""},
      pages:{value: []},
      profileId:{value: ""},
      meta: {computed:"getMeta(profileId)"},
      noAdd:{
        type:Boolean,
        value:false,
      },
      editing:{
        type:Boolean,
        value:false,
      },
      items:{value: []},
      byChild:{type: String, value:'title'},
      loadNum:{type: Number, value: 10},
      startAt:{computed:"getStartAt(pages, find)"},
      pagesLength:{computed:"getPagesLength(pages)"},
      useTemplates: Object,
      pageing:{
        type:Boolean,
        value:false,
      },
      cardPart:{
        observer: "changingPart",
        value:false,
      },
      cardIcons:{
        value: []
      },
      _runTricks:{
        computed: "testStuff(line, tricks, selectedItemIndex, quill)"
      },
      _addingLine:{
        computed: "setAddingLine(quill)"
      },
      tricks:{
        value:{
          signedOff:{
            intent: "^(add|with|my) (sign(ed)?([- ]?)off|signature)",
            icon: "assignment-turned-in",
            action: function (signedOff) {
              var stuff = signedOff.quill
              var op = signedOff.quillOp
              // check if the user has private key
              
              return db.collection("Users").doc(firebase.auth().currentUser.uid).get().then(function(doc) {  
                var data = doc.data()
                if (data.privateKey) {            
                  return data
                } else { // if no private key make one
                  return generate(function(key) {
                    db.collection("Users").doc(firebase.auth().currentUser.uid).set({"privateKey": key},{merge:true})
                  }, function(key) {
                    // public key
                    db.collection("Profiles").where("owner." + firebase.auth().currentUser.uid, "==", true).get().then(function(Profiles) {
                      Profiles.docs.forEach(function(Profile) {
                        Profile.ref.collection("public key").doc(firebase.auth().currentUser.uid).set({"Public key": key})
                      })
                    })
                  })
                }
              }).then(function(keys) {
                return sign(JSON.stringify(stuff), keys.privateKey, function(signature){
                  return [{insert: "âœ” " + signature}]
                })
              }).catch(function(e) {
                console.log(e)
              })
            }
          },
          validateSignature:{
            intent: "^([a-zA-Z0-9+/]{86}==)$",
            signature: "$1",
            icon: "verified-user",
            action: function (validateSignature) {
              
              var stuff = validateSignature.quill
              var op    = validateSignature.quillOp
              
              console.log(validateSignature)
              // match the signature against all known public keys
              
              // check for new Public keys check against any you haven't checked against
              
              // if no valid public key, Mark the signature is invalid
              // if the key matches a public key get the profile image and name
              // Mark the signature has valid, by giving it a big green tick profile image and name
              return [{insert: "âœ” "+validateSignature.signature}]
              return [{insert: "âœ– "+validateSignature.signature}]
            }
          },
          dek:{
            intent:"^(?:put|add)(?: this)? (?:to|in) de[ck]+?([ \\w])*$",
            icon: "content-copy",
          },
          files: {
            intent: "^add (file|document)$",
            ask: ["for files"],
            icon: "editor:insert-drive-file",
          },
          reminder: {
            intent: "^add reminder$",
            ask: ["for date/time"],
            icon: "alarm-on",
          },
          timer: {
            intent: "^(add|make|setup a|start) timer (?:for )?([\\d]+) min(?:utes)?$",
            minutes: "$1",
            icon: "alarm",
          },
          setsReps: {
            sets:   "$1",
            reps:   "$2",
            weigth: "$3",
            rest:   "$4",
            intent: "^([\\d]+) (?:set(?:s)? )?of ([\\d]+)(?:(?: repetition| rep)?(?:s)?)? at ([\\d]+)(?:(?: )?(?:kilo|Kilogram|kg)(?:s)?)?(?: with| and) ([\\d]+)(?: second(?:s)?)?(?: rest(?:s)?)?$",
            icon:   "places:fitness-center",
            action: function (setsReps) {
              var index
              var insert = []
              
              for (index = 0; index < +setsReps.sets; ++index) {
                insert.push({insert: setsReps.reps + " reps at " + setsReps.weigth + "kg\n"})
                if (index !== (+setsReps.sets) - 1) {
                  insert.push({insert: setsReps.rest + " seconds rest \n"})
                }
              }
 
              return insert
            },
            chips: {
              next: function (quill, quillElements, dataRef, timer, update) {
                if (!timer) {
                  clearInterval(this.timer)
                }
                
                function play(bells) {
                  this.audioDing = document.createElement('audio')
                  this.audioDing.setAttribute('src', 'https://firebasestorage.googleapis.com/v0/b/deko-app-one.appspot.com/o/bell.mp3?alt=media&token=5c83f37c-29d9-4971-aef4-aad504477bbc')
                  this.audioDing.setAttribute('autoplay:false', 'autoplay')
                  if (bells == 1){
                    this.audioDing.currentTime = .8
                  } else if (bells == 2){
                    this.audioDing.currentTime = .4
                  }
                  this.audioDing.play()
                }
                // Look for n reps at n kg
                // set next to heading 3 (first if no set)
                // if n seconds rest n = n - 1 and 
                var newQuill = new Quill(document.createElement("div"), {})
                newQuill.setContents(quill)
                var steps = []
                var ops = []
                var that = this
                newQuill.getLines().forEach(function (line, idx) {
                  var op = {insert:line.cache.delta.ops[0].insert}
                  var regex = /[\d]+ reps at [\d]+kg$|^(?:([\d]+)\/)?([\d]+) seconds rest $/gm
                  var m
                  if (typeof op.insert === "string" && (m = regex.exec(op.insert)) !== null) {
                    if (!line.cache.delta.ops[1] || (timer && line.cache.delta.ops[1].attributes && line.cache.delta.ops[1].attributes.header == 2 && +m[1] == m[1])) {
                      steps.push({
                        idx: idx,
                        text:op.insert,
                        line:line,
                      })
                      if (steps.length === 1) {
                        if (!line.cache.delta.ops[1]) {
                          op.attributes = {"header":2}
                        }
                        if (m[1] === undefined && +m[2] && !timer) {
                          // 100 => 0/100 making m[1] == 0
                          op.insert = "0/" + op.insert
                          function tick() {
                            // maybe use quillElements.getContents() or quill
                            var _quill = that.next(quillElements.getContents().ops, quillElements, dataRef, true, update)
                            quillElements.setContents(_quill)
                            update(_quill)
                          }
                          clearInterval(that.timer)
                          setTimeout(function() {
                            that.timer = setInterval(tick, 1000)
                          }, 500)
                        } else if (+m[1] == m[1] && timer) {
                          // 80/100 => 81/100 
                          op.insert = ++m[1] + "/" + m[2] + " seconds rest "
                        } else {
                          clearInterval(that.timer)
                        }
                        if (10 + m[1] === +m[2] && timer) {
                          play(1)
                        }
                        
                        if (+m[1] === +m[2] && timer) {
                          op.insert = op.insert + " done \n"
                          if (line.cache.delta.ops[1]) {
                            delete(line.cache.delta.ops[1])
                          }
                          setTimeout(function() {
                            update(that.next(quillElements.getContents().ops, quillElements, dataRef, false, update)) // move on
                          }, 50)
                        }
                      }
                    } else {
                      op.insert = line.cache.delta.ops[0].insert + " done \n"
                      if (line.cache.delta.ops[1]) {
                        delete(line.cache.delta.ops[1])
                      }
                      if (line.cache.delta.ops[2]) {
                        delete(line.cache.delta.ops[2])
                      }
                    }
                  }
                  if (idx === 0) {
                    op.attributes = {"header":1}
                  }
                  ops.push(op)
                  
                  if (line.cache.delta.ops[1]) {
                    ops.push(line.cache.delta.ops[1])
                  }
                  if (line.cache.delta.ops[2]) {
                    ops.push(line.cache.delta.ops[2])
                  }
                  
                })
               
                // this.tricks.setsReps.timeout = setTimeout(this.tricks.setsReps.chips.next,1000)
                if (window.speechSynthesis && !timer && steps[0] && steps[0].text) {
                  window.speechSynthesis.speak(new SpeechSynthesisUtterance(steps[0].text))
                } else if (steps.length === 0){
                  dataRef.set({setsReps: "done"}, {merge: true})
                }

                return ops
              },
              _tick:function(quill) {
                // next
                
                return quill
              },
            },
            numberOfSets: function (str) {
              var regex = /^[\d]+ reps at [\d]+kg( done)?/gmi
              var m
              var n = 0
              while ((m = regex.exec(str)) !== null) {
                // This is necessary to avoid infinite loops with zero-width matches
                if (m.index === regex.lastIndex) {
                  regex.lastIndex++;
                }
    
                // The result can be accessed through the `m`-variable.
                m.forEach((match, groupIndex) => {
                  n++
                })
              }
              return n
            },
            numberOfDone: function (str) {
              var regex = /^[\d]+ reps at [\d]+kg done/gmi
              var m
              var n = 0
              while ((m = regex.exec(str)) !== null) {
                // This is necessary to avoid infinite loops with zero-width matches
                if (m.index === regex.lastIndex) {
                  regex.lastIndex++;
                }
    
                // The result can be accessed through the `m`-variable.
                m.forEach((match, groupIndex) => {
                  n++
                })
              }
              return n
            },
            value:"$1 sets of $2 reps at $3kg and $4 rests",
            timeout: 0,
          },
        },
      },
      iconTricks: {
        computed:"getIconTricks(tricks)",
      },
      commands: {
        computed:"getCommands(cardPart,items,selectedItemIndex)",
      },
      _tableCommands: {
        computed:"getTableCommands(items,selectedItemIndex)",
      },
      selectedItemIndex: {computed:"_items(items)"},
      apiURL: {
        value: "https://us-central1-deko-app-one.cloudfunctions.net/god/"
      },
    },
    getMeta: function(profileId) {
      var meta = {}
      meta[profileId] = "profileId"
      return meta
    },
    imageIndex: function() {
      var that = this
      if (lunr) {
        return db.collection("Profiles").doc(that.profileId).collection("lunr_index").doc("images").get().then(function(doc) {
          return lunr.Index.load(JSON.parse(doc.data().idx))
        }).catch(e => {
          console.log(e)
          return "Error"
        })
      } else {
        console.log(lunr)
        return "Error"
      }
    },
    fireChip: function(e,d){
      var that = this
      var chipText = encodeURIComponent(e.currentTarget.innerText.replace("\n",""))
      if (chipText === "Getting") {
        that.tableCommands = ["Still Getting"]
        return
      }
      if (chipText === "Still%20Getting") {
        that.tableCommands = []
        return
      }
      
      this.set("tableCommands", ["Getting"])
      
      fetch(this.apiURL + "pik/deko/" + chipText).then(function(response) {
        return response.json()
      }).then(function(response) {
        that.tableCommands = ["Got it"]
        if (response.add) {
          response.add.selected = true
          that.set("items", that.items.map(function(x){ 
            x.selected = false
            return x
          }).concat([response.add]))
          
          that.set("editing", true)
          that.set("cardPart", 1)
          
          that.newCard({
            value: response.add.quill,
            time:  Date.now(), // firebase.database.ServerValue.TIMESTAMP,
            user:  firebase.auth().currentUser.uid,
          })
        }
      })
    },
    getItem: function(items, selectedItemIndex) {
      if (selectedItemIndex !== false) {
        return items[selectedItemIndex]
      }
      return false
    },
    getTableCommands: function(items, selectedItemIndex) {
      if (selectedItemIndex === false) {
        if (items.length === 0) {
          this.set("tableCommands",["Welcome,ðŸ˜Ž tap here and I'll give you a card"])
          return
        }
      }
      this.set("tableCommands",[])
    },
    getCommands: function(cardPart, items, selectedItemIndex) {
      var selectedCard = items[selectedItemIndex]
      if (cardPart === 0) {
        if (selectedCard !== false && selectedCard && selectedCard.ref) {
          return ["Delete","Show it"]
        } else {
          return ["Disregard","Save"]
        }
      } else if (cardPart === 1) {
        this.prompt = ""
        if (selectedCard && selectedCard.setsReps) {
          if (selectedCard.setsReps === "Done") {
            return ["Share","Done"]
          }
          return ["Next","Done","Edit"] 
        }
        return ["Edit","Give","Done"] 
      } else {
        // get tricks
      }
    },
    addTextSetPrompt: function(d) {
      var that = this
      if (this.cardPart == 0) {
        //edit
        this.quill.focus()
        var cur = this.quill.getSelection().index
        var textToAdd = "\n" + d.detail.chip.trim() + " "
        this.quill.insertText(cur + 1, textToAdd)
        this.quill.setSelection(cur + 1 + textToAdd.length)
        this.line = d.detail.chip.trim() + " "
        this.chips = []
      } else if (this.cardPart == 1) {
        console.log(d.detail.chip.trim())
        var textOnChip = d.detail.chip.trim().toLowerCase()
        var selectedItem = that._items(this.items)
        function testForFunction (text) { // Returns relevant first trick
          return Object.keys(that.items[selectedItem]).filter(
            function (current) {
              if (current !== "ref" && that.tricks.hasOwnProperty(current) && that.tricks[current].chips){
                return that.tricks[current].chips.hasOwnProperty(text)
              } else {
                return false
              }
            }
          )[0]
        }
        if (textOnChip === "give") {
          that.chips = that.profileList.map(function(profile) {
            return profile.name
          }).filter(function(name) {
            return name
          })
        } else if (testForFunction(textOnChip)) {
          if (typeof that.tricks[testForFunction(textOnChip)].chips[textOnChip] === "function" && that.items[selectedItem].quill) {
            function update(newQuill) {
              that.set("items."+ selectedItem +".quill", newQuill) //TODO is both needed? 
              that.quill.setContents(newQuill)
            }
            var newQuill = that.tricks[testForFunction(textOnChip)].chips[textOnChip](that.items[selectedItem].quill, that.showQuill, that.items[selectedItem].ref, false, update)
            update(newQuill)
          }
        } else if (this.profileList.filter(function(profile) {return profile.name === textOnChip})[0]) {
          var id = this.profileList.filter(function(profile) {
            return profile.name === textOnChip
          })[0].id
          
          if (this.items[selectedItem].ref) {
            that.chips = ["giving"]
            var given = {}
            given[id] = true
            this.items[selectedItem].ref.set({given:given}, {merge: true}).then(function(){
              that.$$("open-card").close()
              that.chips = []
              if (that.unsub) {
                that.unsub()
              }
              if (that.resub) {
                that.resub()
              }
            }).catch(function(e){
              console.log(e)
            })
          }
        }
      }
    },
    setAddingLine: function(quill) {
      if (quill) {
        var that = this
        quill.on('text-change', function(theDelta, oldDelta, theSource) {
          if (quill.getSelection() && quill.getSelection().index) {
            var onLine = quill.getLine(quill.getSelection().index)[0].domNode.outerText
            if (that.addingLine !== onLine) {
              that.set("line", onLine)
            }
          } else {
            that.set("line", "")
          }
        })
      }
    },
    getIconTricks: function(tricks) {
      return Object.keys(tricks).reduce(function(icons, value) {
        icons.push(tricks[value])
        return icons
      }, [])
    },
    noDrag: function(e) {
      e.stopPropagation()
    },
    new: function(card) {
      this.set("items", this.items.map(function(x){ 
        x.selected = false
        return x
      }).concat([{
        selected: true,
        image:"",
        quill: [
          {insert: "\n", attributes: {header:1}},
        ],
        title: "",
      }]))
      this.cardPart = 0
      
      this.editing = true
      if (this.unsub) {
        this.unsub()
      }
      var n = 0
      var that = this
      var open = function() {
        
        that.$$("open-card").open()
        that.debounce("focus", function() {
          try {
            that.quill.focus()
            that.quill.setContents([
              {insert: "\n", attributes: {header:1}},
            ])
          } catch (e) {
            if (++n < 100) {
              open()
            }
          }
        },10)
      }
      this.debounce("open", open, 10)
    },
    newCard: function(toAddQuill) {
      var that = this
      var selectedItem = this._items(this.items)
      
      var save = {}
      for (var key in this.items[selectedItem]) {
        if (key !== "quill" && key !== "selected") {
          save[key] = this.items[selectedItem][key]
        }
      }
      
      that.cards.add(JSON.parse(JSON.stringify(save))).then(function(doc) {
        that.set("items."+ selectedItem +".ref", doc)
        if (toAddQuill) {
          doc.collection("quill").add(toAddQuill).then().catch()
        }
        that.set("loading", false)
      }).catch(function(error) {
        console.error("Error adding card: ", error)
      })
    },
    deleteCard: function(e,d) {
      var that = this
      var selectedItem = this._items(this.items)
      if (selectedItem !== false && that.items[selectedItem] && that.items[selectedItem].ref && that.items[selectedItem].ref.id) {
        var deleteId = that.items[selectedItem].ref.id
        that.items[selectedItem].ref.delete().then(function() {
          that.set("items", that.items.reduce(function(accumulator, currentValue) {
            if (that.items[selectedItem] && that.items[selectedItem].ref && that.items[selectedItem].ref.id !== deleteId) {
              accumulator.push(currentValue)
            }
            return accumulator
          },[]))
        }).catch(function(error) {
          console.error("Error removing card: ", error);
        })
      }
      this.resub()
    },
    testStuff: function(line, tricks, selectedItem, quill){
      if (!this.editing) {
        return
      }
      var that = this 
      selectedItem = this._items(this.items)
      var newQuill = new Quill(document.createElement("div"), {})
      newQuill.setContents(quill.getContents().ops)
      newQuill.formatLine(1, 2, 'attributes', {header:1})
      
      var stuff = newQuill.getContents().ops

      var name
      var head
      var headAt
      var image
      var add
      var addAt
      var text = quill.getText().replace("\n", "")
      if (!text) {
        return "nothing to test"
      }
      if (text.indexOf("logout") !== -1 && !this.items[selectedItem].ref) {
        this.fire("logout")
      }
      if (!this.items[selectedItem]) {
        this.items[selectedItem] = {}
      }
      var title = this.items[selectedItem].title
      if (title){
        text = text.replace(title, "")
        this.items[selectedItem].autoImage = this.imageIndex().then(function(idx){
          var result = idx.search(title)
          if (result.length) {
            return "" + result[0].ref
          } else {
            return ""
          }
        })
      }
      if (firebase.storage && this.items[selectedItem].image === '' && this.items[selectedItem].autoImage) {
        this.items[selectedItem].autoImage.then(function (imageRef) {
          if (!imageRef) {
            return "no image"
          }
          return firebase.storage().ref().child(imageRef).getDownloadURL().then( function (url) {
            var image = url
            if (image.split("%2F")[1]) { //TODO DRY
              db.collection("files").doc(image.split("%2F")[1]).get().then(function(doc) {
                if (doc.exists && doc.data() && doc.data().vision && doc.data().vision[0].imagePropertiesAnnotation) {
                  var colour = doc.data().vision["0"].imagePropertiesAnnotation.dominantColors.colors["0"].color
                  function componentToHex(c) {
                    var hex = c.toString(16)
                    return hex.length == 1 ? "0" + hex : hex
                  }
                  function rgbToHex(r, g, b) {
                    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
                  }
                  var toolbarColor = rgbToHex(colour.red || 0, colour.green || 0, colour.blue || 0)
                  
                  that.set(["items",selectedItem,"toolbarColor"], toolbarColor)
                  
                  that.debounce("updateCardToolbarColor", function () {
                    if (that.items[selectedItem].ref) {
                      that.items[selectedItem].ref.set({toolbarColor: toolbarColor}, {merge: true})
                    }
                  },1000)
                }
              })
            }
            if (that.items[selectedItem].ref) {
              that.debounce("updateCardImage", function () {
                that.items[selectedItem].ref.set({image:url}, {merge: true})
              }, 2000)
            }
            return that.set(["items",selectedItem,"image"], url)
          })
        })
      }
      if (this.items[selectedItem].text !== text) {
        this.items[selectedItem].text = text
        if (this.items[selectedItem].ref) {
          this.debounce("updateCardText", function () {
            this.items[selectedItem].ref.set({text: text}, {merge: true})
          }, 2000)
        }
      }
      for (var op in stuff) {
        if (stuff[op].insert && typeof stuff[op].insert  === 'string') {
          if (!name) { 
            name = stuff[op].insert.split("\n")[0]
            if (name) {
              if (!stuff[op].attributes) {
                var notName = stuff[op].insert.split("\n").splice(1).join("\n")
                if (notName.replace(/[^0-9a-z-A-Z ]/g, "").trim()) {
                  head = [
                    {insert: name},
                    {insert: "\n", attributes: {header:1}},
                    {insert: notName},
                  ]
                  headAt = op
                }
              }
              title = name.replace(/[^0-9a-z-A-Z\/ ]/g, " ").trim()
              if (!title) {
                return "no title"
              }
              if (this.items[selectedItem].title !== title) {
                this.items[selectedItem].title = title
                this.items[selectedItem].image = '' // new title reset image
                if (this.items[selectedItem].ref) {
                  this.debounce("updateCardTitle", function () {
                    if (!title) {
                      return "no title"
                    } else {
                      return this.items[selectedItem].ref.set({title: title}, {merge: true})
                    }
                  }, 2000)
                }
              }
              
            } else if (stuff[op].insert.split("\n").join("") || (this.items[selectedItem] && !this.items[selectedItem].title)) {
              this.items[selectedItem].title = stuff[op].insert.split("\n").join("")
              if (this.items[selectedItem].ref) {
                this.debounce("updateCardTitle", function () {
                  this.items[selectedItem].ref.set({title:this.items[selectedItem].title}, {merge: true})
                }, 2000)
              }
            }
          } else if (!add) {
            var lines = stuff[op].insert.split("\n")
            for (var line in lines) {
              var toAdd = lines[line]
              if (toAdd) {
                for (var trick in tricks) {
                  var regex = new RegExp(tricks[trick].intent, "gmi")
                  var matchs
                  while ((matchs = regex.exec(toAdd)) !== null && !add) {
                    if (matchs.index === regex.lastIndex) {
                      regex.lastIndex++
                    }
                    
                    var addBefore = lines.splice(0, +line   ).join("\n")
                    addAt = op
                    var addAfter  = lines.splice(1 + +(line)).join("\n")
                  
                    if (typeof tricks[trick].action === "function") {
                      var theTrick
                      
                      if (!tricks[trick].split) {
                        theTrick = JSON.parse(
                          toAdd.replace(regex, JSON.stringify(tricks[trick])).replace(/(\n|\t)/gm,"\\n")
                        )
                      } else {
                        theTrick = JSON.parse(
                          toAdd.replace(new RegExp(tricks[trick].split, "gm"), "\\n").replace(regex, JSON.stringify(tricks[trick])).replace(/(\n|\t)/gm,"\\n")
                        )
                      }
                      this.set(["items",selectedItem,trick], theTrick)
                      
                      theTrick.quill = stuff
                      theTrick.quillOp = op
                      
                      add = [{insert: addBefore + "\n"}].concat(tricks[trick].action(theTrick), [{insert: addAfter + "\n"}])
                      
                    } else if (tricks[trick].action) {
                      var theTrick
                      
                      if (!tricks[trick].split) {
                        theTrick = JSON.parse(
                          toAdd.replace(regex, JSON.stringify(tricks[trick])).replace(/(\n|\t)/gm,"\\n")
                        )
                      } else {
                        theTrick = JSON.parse(
                          toAdd.replace(new RegExp(tricks[trick].split, "gm"), "\\n").replace(regex, JSON.stringify(tricks[trick])).replace(/(\n|\t)/gm,"\\n")
                        )
                      }
                      
                      add = [{insert: addBefore + "\n"}].concat(theTrick.action, [{insert: addAfter + "\n"}])
                      this.set(["items",selectedItem,trick], theTrick)
                    } else {
                      add = [
                        {insert: addBefore + "\n"},
                        {insert: addAfter  + "\n"},
                      ]
                    }
                    if (tricks[trick].icon) {
                      if (this.cardIcons.indexOf(tricks[trick].icon) === -1) {
                        this.push("cardIcons", tricks[trick].icon)
                      }
                    }
                    this.set(["items",selectedItem,trick], theTrick)
                    if (this.items[selectedItem].ref) {
                      var toSave = {}
                      toSave[trick] = theTrick
                      this.debounce("updateCardTrick", function () {
                        this.items[selectedItem].ref.set(toSave, {merge: true})
                      }, 2000)
                    }
                  }
                }
              }
            }
          } 
        } else if (!image || this.items[selectedItem].image !== image) {
          if (stuff[op].insert && typeof stuff[op].insert  === 'object' && stuff[op].insert.image) {
            image = stuff[op].insert.image
            if (this.items[selectedItem].image !== image) {
              this.set(["items",selectedItem,"image"], image)
              if (image.split("%2F")[1]) { //TODO DRY
                var that = this
                db.collection("files").doc(image.split("%2F")[1]).get().then(function(doc) {
                  if (doc.exists && doc.data() && doc.data().vision && doc.data().vision[0].imagePropertiesAnnotation) {
                    var colour = doc.data().vision["0"].imagePropertiesAnnotation.dominantColors.colors["0"].color
                    function componentToHex(c) {
                      var hex = c.toString(16)
                      return hex.length == 1 ? "0" + hex : hex
                    }
                    function rgbToHex(r, g, b) {
                      return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
                    }
                    var toolbarColor = rgbToHex(colour.red || 0, colour.green || 0, colour.blue || 0)
                    
                    that.set(["items",selectedItem,"toolbarColor"], toolbarColor)
                    that.debounce("updateCardToolbarColor", function () {
                      this.items[selectedItem].ref.set({toolbarColor: toolbarColor}, {merge: true})
                    },1000)
                  }
                })
              }
              if (this.items[selectedItem].ref) {
                this.debounce("updateCardImage", function () {
                  this.items[selectedItem].ref.set({image: image}, {merge: true})
                },2000)
              }
            }
          }    
        } 
//        if (stuff[op].insert && stuff[op].insert.image) {
//          if (stuff[op].insert.image.length > 1000*1000) {
//            this.resizeImage(stuff, op)
//          }
//        }
      }
      if (head) {
        stuff = stuff.splice(0, +headAt).concat(head, stuff.splice(1 + +(headAt)))
      } else if (add) {
        stuff = stuff.splice(0, +addAt ).concat(add,  stuff.splice(1 + +(addAt) ))
      }
      if (add || head) {
        this.debounce("updateCard", function () {
          if (JSON.stringify(this.items[selectedItem].quill) !== JSON.stringify(stuff)) {
            var that = this
            var quillSave = {
              value: stuff,
              time:  Date.now(), // firebase.database.ServerValue.TIMESTAMP,
              user:  firebase.auth().currentUser.uid,
            }
 
            if (this.items[selectedItem].ref) {
              this.items[selectedItem].ref.collection("quill").add(quillSave).then(function(data) {
                that.set("savedQuill",true)
              })
            } else {
              this.newCard(quill)
            } 

            if (!this.items[selectedItem]) {
              this.items[selectedItem] = {}
            }
            this.set(["items",selectedItem,"quill"], stuff)
            this.quill.setContents(stuff)
          }
        }, 2000)
      }
    },
//    resizeImage: function(stuff, opForImage) {
//      var that = this
//      loadImage(
//        stuff[opForImage].insert.image,
//        function (canvas) {
//          if (canvas.toDataURL) {
//            stuff[opForImage].insert.image = canvas.toDataURL()
//            that.set(["items",selectedItem,"quill"], stuff.map(function(x) {return x}) )
//          }
//        }, {
//          canvas: true,
//          maxHeight: 500,
//          maxWidth: 500,
//          orientation: true,
//        }
//      )
//    },
    changingPart: function(part, partFrom) {
      var selectedItem = this._items(this.items)
      var that = this
      var ref
      if (part == 1) {
        this.chips = []
      }
      if (that.items[selectedItem]) {
        ref = that.items[selectedItem].ref
      }
      if (part == 0 && partFrom == 1){
        if (ref) {
          that.set("loading", true)
          ref.collection("quill").orderBy("time", "desc").limit(1).get().then(function(data) {
            that.set("loading", false)
            if (data && data.size) {
              var value = data.docs[0].data().value
              if (JSON.stringify(that.items[selectedItem].quill) !== JSON.stringify(value)) {
                that.set(["items",selectedItem,"quill"], value)
              }
            } else {
//              that.set(["items",selectedItem,"quill"], [{"insert":"\n"}])
            }
          })
        }
      }
      if (part == 1 && partFrom == 0 && this.quill && this.items[selectedItem].quill && JSON.stringify(this.items[selectedItem].quill) != JSON.stringify([{"insert":"\n"}])){
        var quill = {
          value: this.quill.getContents().ops,
          time:  Date.now(), // firebase.database.ServerValue.TIMESTAMP,
          user:  firebase.auth().currentUser.uid,
        }
        
        this.items[selectedItem].quill = this.quill.getContents().ops
        
        if (ref) {
          ref.collection("quill").add(quill).then(function(data) {
            that.set("savedQuill",true)
          })
        } else {
          that.newCard(quill)
        }
      }
    },
    addToCard: function(cardRef) {
      var selectedItem = this._items(this.items)
      if (selectedItem !== false && this.items[selectedItem].title) {
        var that = this
        cardRef.set({
          title: that.items[selectedItem].title,
          toolbarColor: that.items[selectedItem].toolbarColor,
        },{merge:true}).then(function() {
          that.set(["items",selectedItem], {
            ref:   cardRef,
            title: that.items[selectedItem].title,
            toolbarColor: that.items[selectedItem].toolbarColor,
            selected: true,
          })
          if (that.items[selectedItem].image) {
            cardRef.collection("image").add({
              value: that.items[selectedItem].image,
              time:  Date.now(), // firebase.database.ServerValue.TIMESTAMP,
              user:  firebase.auth().currentUser.uid,
            }).then()
          }
        })
      }
    },
    render: function() {
      this.go = !this.go
      if (this.$$("#list0")) this.$$("#list0").render()
      if (this.$$("#list1")) this.$$("#list1").render()
    },
    getStartAt: function(pages, find){
      if (find) {
        return find
      } else if (pages.length) {
        return pages[pages.length - 1].start
      } else {
        return ""
      }
    },
    perv: function(){
      this.pages.pop()
      if (this.pages.length) {
        this.find = this.pages[this.pages.length - 1].start
      } else {
        this.find = ""
      }
      this.pages = this.pages.map(function(x) {return x}) // update
      return 1
    },
    next: function(){
      var start = this.nextPageStartAt
      this.find = start
      // var end = this.end
      if (this.pages.length === 0 || start !== this.pages[this.pages.length-1].start) { // && this.pages.length < end) {
        this.pages.push({
          start: start,
        })
        this.pages = this.pages.map(function(x) {return x}) // update 
        
        return 1
      }
      return 0
    },
    getPagesLength: function(pages){
      return pages.length
    },
    setItems: function(ref, byChild, loadNum, startAt, wide){
      if (this.editing) {
        return
      }
      var that = this
      if (!wide) {
        loadNum = 5
      }
      function objectToArray(data) {
        var output = []
        if (data) {
          var keys = Object.keys(data)
          for (var i = 0; i < keys.length; i++) {
            if (typeof data[keys[i]] === 'object') {
              data[keys[i]].__key = keys[i]
              output.push(data[keys[i]])
            }
          }
        }
        return output
      }
      function sortByChild (a,b){
        if (a.hasOwnProperty(byChild) && b.hasOwnProperty(byChild)) {
          var A = a[byChild].toUpperCase()
          var B = b[byChild].toUpperCase()       
          if (A < B) { return -1 }
          if (A > B) { return 1 }
        }
        return 0
      }
      var setItems = function(snap) {
        var theSnap = snap.docs
        if (theSnap && !snap.empty ) {
          that.set("loaded", theSnap.length)
          // that.items = theSnap.sort(sortByChild) 
          var cards = []
          theSnap.forEach(function(doc) {
            var docData = doc.data()
            if (!docData.given) {
              cards.push({
                title: docData.title,
                image: docData.image,
                toolbarColor: docData.toolbarColor,
                dek: docData.dek,
                show: docData.show,
                text: docData.text,
                timer: docData.timer,
                reminder: docData.reminder,
                signedOff: docData.signedOff,
                setsReps: docData.setsReps,
                ref: doc.ref,
              })
            }
          })
          that.set("editing", false)
          that.set("items", cards)
          that.render()
          if (that.loaded == +loadNum) {
            if (that.items[+loadNum - 1][byChild]) {
              that.nextPageStartAt = that.items[+loadNum - 1][byChild] + "~"
            } else {
              that.nextPageStartAt = "A"
            }
          } else {
            that.nextPageStartAt = null
            that.end = 1+that.pagesLength
          }
        } else {
          that.nextPageStartAt = null
          that.end = 1+that.pagesLength
          that.items = []
        }
      }
      var listRef
      if (byChild === "__key"){
        listRef = ref
      } else {
        listRef = ref.orderBy(byChild)
      }
      if (this.unsub) {
        this.unsub()
      }
      if (startAt) {
        this.unsub = listRef.startAt(startAt).limit(+loadNum).onSnapshot(setItems)
      } else {
        this.unsub = listRef.limit(+loadNum).onSnapshot(setItems) // TODO 
      }
    },
    open: function(e,d){
      if (this.unsub) {
        this.unsub()
      }
      this.editing = true
      this.fire("open-card", {e:e,d:d})
    },
    pickable: function(item){
      return !item.selected
    },
    selected: function(item){
      return item.selected || false
    },
    reduceToIndexOfSelected: function(accumulator, card, currentIndex){
      if (card.selected) {
        accumulator = currentIndex
      }
      return accumulator
    },
    select: function(e){
      var pick = e.target.parentNode.parentNode.card || e.target.parentNode.card || e.target.card
      var that = this
      
      var id = ""
      
      if (pick.ref){
        id = pick.ref.id
        pick.ref.collection("quill").orderBy("time", "desc").limit(1).get().then(function(data) {
          if (data && data.size) {
            var value = data.docs[0].data().value
            var selectedItem = that._items(that.items)
            that.set("items."+ selectedItem +".quill", value)
          } else {
            that.set("items."+ selectedItem +".quill", [{"insert":"\n"}])
          }
        })
      }

      this.items = this.items.map(function(x,i){
        if (x.ref && x.ref.id === id) {
          x.selected = true
        } else {
          x.selected = false
        }
        return x
      })
      this._items(this.items)
    },
    selectOpen: function(e){
      this.select(e)
      this.cardPart = 1
      this.$$("open-card").open()
      if (this.unsub) {
        this.unsub()
      }
      this.editing = true
    },
    resub: function(e){
      this.editing = false
      this.setItems(this.cards, this.byChild, this.loadNum, this.startAt, this.wide)
    },
    _items: function(items){
      if (items && items !== null && items.length && items.filter(this.selected).length === 0) {
        this.items[items.length - 1].selected = true
      }
      if (items && items !== null && items.length) {
        return this.items.reduce(this.reduceToIndexOfSelected, false)
      }
      return false
    },
    getFg: function(bg){
      if (bg) {
        var c = bg.substring(1);     // strip #
        var rgb = parseInt(c, 16);   // convert rrggbb to decimal
        var r = (rgb >> 16) & 0xff;  // extract red
        var g = (rgb >>  8) & 0xff;  // extract green
        var b = (rgb >>  0) & 0xff;  // extract blue
        var luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709
        if (luma > 128) {
          return "#000"
        } else {
          return "#FFF"
        }
      } else {
        return "#FFF"
      }
    },
    ready: function(){
      var that = this
      fetch(this.apiURL + "profiles").then(function(response) {
        return response.json()
      }).then(function(response) {
        that.profileList = response
      })
    },
  })
  function importKey(KeyAsJson,cb) {
  var key = JSON.parse(KeyAsJson)
  window.crypto.subtle.importKey("jwk", key,{name: "ECDSA",namedCurve: "P-256"}, false,key.key_ops).then(function(key){
    cb(key)
  }).catch(function(err){
    console.error(err)
  })
}
function ab2str(buf) {
  return String.fromCharCode.apply(null, new Uint16Array(buf));
}
function str2ab(str) {
  var buf = new ArrayBuffer(str.length*2); // 2 bytes for each char
  var bufView = new Uint16Array(buf);
  for (var i=0, strLen=str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf
}
function arrayToBase64String(ab){
  var dView = new Uint8Array(ab)   //Get a byte view
  var arr = Array.prototype.slice.call(dView) //Create a normal array
  var arr1 = arr.map(function(item){
    return String.fromCharCode(item)    //Convert
  })
  return window.btoa(arr1.join(''))  //Form a string
}

function base64ToArrayBuffer(s) {
  var asciiString = window.atob(s)
  return new Uint8Array([...asciiString].map(char => char.charCodeAt(0)))
}

// sign takes a string to be signed and a private key and a call back which is fired with the argument of the signature
function sign(string, privateKey, cb) {
  var data = str2ab(string)
  var key = JSON.parse(privateKey)
  importKey(privateKey,function(key){
    window.crypto.subtle.sign({name: "ECDSA", hash: {name: "SHA-256"},}, key, data).then(function(signature){
      return cb(arrayToBase64String(signature))
    }).catch(function(err){
      console.error(err)
    })
  })
}

function exportKey(Key,cb) {
  return window.crypto.subtle.exportKey("jwk", Key).then(function(keydata){
    //returns the exported key data
    var key = JSON.stringify(keydata)
    cb(key)
    return key
  }).then(function(key){
    return key
  }).catch(function(err){
    console.error(err)
  })
}
// this function takes a callback which fires twice once for the public key and once for the private key 
function generate(cb, cb2) {
  var keys = {}
  return window.crypto.subtle.generateKey({ name: "ECDSA", namedCurve: "P-256"}, true, ["sign", "verify"]).then(function(key){
    return exportKey(key.privateKey,cb).then(function(privateKey){
      keys.privateKey = privateKey
      return exportKey(key.publicKey,cb2).then(function(publicKey){
        keys.publicKey = publicKey
      })
    }).then(function(){
      return keys
    })
  }).catch(function(err){
    console.error(err)
  })
}
function verify(string, signature, publicKey, cb) {
  var data = str2ab(string)
  importKey(publicKey,function(key){
    window.crypto.subtle.verify({name: "ECDSA",hash: {name: "SHA-256"}}, key, base64ToArrayBuffer(signature), data 
    ).then(function(isvalid){
      //returns a boolean on whether the signature is true or not
      cb(isvalid)
    }).catch(function(err){
      console.error(err)
    })
  })
}
</script>
