<link rel="import" href="../iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../deko-card-container/deko-card-container.html">
<link rel="import" href="../iron-media-query/iron-media-query.html">
<link rel="import" href="../deko-opened-card/deko-opened-card.html">
<link rel="import" href="../deko-signature/deko-signature.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../image-base64/image-base64.html">
<link rel="import" href="../icon-icons/editor-icons.html">
<link rel="import" href="../icon-icons/places-icons.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../input-image/input-image.html">
<link rel="import" href="../deko-card/deko-card.html">
<link rel="import" href="../open-card/open-card.html">
<link rel="import" href="../quill-js/quill-js.html">
<link rel="import" href="../q-card/q-card.html">
<dom-module id="deko-cards">
  <template>
    <style>
      :root {
        --paper-chip-background-color:red;
        --paper-chip-secondary-text-color:#fff;
      }
      *, *:before, *:after { box-sizing: border-box; }
      #card-view {
        margin:auto;max-width:1066px;min-width:150px;min-height:95%;
      }
      .col {
        display: inline-grid;
      }
      .col.stack deko-card {
        margin-bottom: -120%;
      }
    </style>
    <app-route route="{{route}}" pattern="/:data" data="{{routeData}}" tail="{{tail}}"></app-route>
    <div id="card-view">
      <div class="col 0" style$="width: calc(95%/[[cols]])">
        <template is="dom-repeat" items="[[items]]" id="list0" filter="col_1" sort="sortRow">
          <deko-card on-tap="selectOpen" tabindex$="[[index]]" card="[[item]]" ondragover="dragover_handler(event)" >
            <div inner-h-t-m-l="[[item.html]]"></div>
          </deko-card>
        </template>
      </div>
      <div class="col 1" style$="width: calc(95%/[[cols]])">
        <template is="dom-repeat" items="[[items]]" id="list1" filter="col_2" sort="sortRow">
          <deko-card on-tap="selectOpen" tabindex$="[[index]]" card="[[item]]" ondragover="dragover_handler(event)" >
            <div inner-h-t-m-l="[[item.html]]"></div>
          </deko-card>
        </template>
      </div>
      <div class="col 2" style$="width: calc(95%/[[cols]])">
        <template is="dom-repeat" items="[[items]]" id="list2" filter="col_3" sort="sortRow">
          <deko-card on-tap="selectOpen" tabindex$="[[index]]" card="[[item]]" ondragover="dragover_handler(event)" >
            <div inner-h-t-m-l="[[item.html]]"></div>
          </deko-card>
        </template>
      </div>
      <div class="col 3" style$="width: calc(95%/[[cols]])">
        <template is="dom-repeat" items="[[items]]" id="list3" filter="col_4" sort="sortRow">
          <deko-card on-tap="selectOpen" tabindex$="[[index]]" card="[[item]]" ondragover="dragover_handler(event)" >
            <div inner-h-t-m-l="[[item.html]]"></div>
          </deko-card>
        </template>
      </div>
      <div class="col 4" style$="width: calc(95%/[[cols]])">
        <template is="dom-repeat" items="[[items]]" id="list4" filter="col_5" sort="sortRow">
          <deko-card on-tap="selectOpen" tabindex$="[[index]]" card="[[item]]" ondragover="dragover_handler(event)" >
            <div inner-h-t-m-l="[[item.html]]"></div>
          </deko-card>
        </template>
      </div>
      <div class="col 5" style$="width: calc(95%/[[cols]])">
        <template is="dom-repeat" items="[[items]]" id="list5" filter="col_6" sort="sortRow">
          <deko-card on-tap="selectOpen" tabindex$="[[index]]" card="[[item]]" ondragover="dragover_handler(event)" >
            <div inner-h-t-m-l="[[item.html]]"></div>
          </deko-card>
        </template>
      </div>
    </div>
    <!-- testing not updating items  \/{{ }}\/ -->
    <template is="dom-repeat" items="[[items]]" filter="selected" id="opencard">
      <open-card svg="/images/deko.svg" prompt="[[prompt]]" on-chip="addTextSetPrompt" chips="[[chips]]" other-chips="[[commands]]" selected="{{cardPart}}" on-cancel="deleteCard" on-done="resub" on-new="new">
        <div>
          <deko-card style="margin: auto;min-width: 330px;display: block;width: 80%;" card="[[item]]" display="open">
            <div id="editor" ></div>
            
          </deko-card>
          <q-card part="[[cardPart]]" line="[[line]]" editor="[[quill]]" meta="[[meta]]" tricks="[[tricks]]" card="{{item}}" prompt="{{prompt}}" chips="{{chips}}"></q-card>
        </div>
        <div style="margin: auto;max-width:100%;width:1000px;">
          <deko-card style="margin: auto;min-width: 365px;display: block;width: 80%;" card="[[item]]" display="open">
            <div id="show" inner-h-t-m-l="[[item.html]]"></div>
          </deko-card>
          <div style="text-align:center">
            <template is="dom-repeat" items="[[item._signatures]]" as="sig">
              <deko-signature id="[[toId(sig.signature)]]" signature="[[sig.signature]]" to-test="[[sig.stuff]]"></deko-signature><br>
            </template>
          </div>
        </div>
      </open-card>
    </template>
    <!-- <image-base64 url="[[selectedItem.image]]" max-height="200" max-width="200" base64="{{addingImage}}"></image-base64>
    -->
    <div style="max-width: 500px">
      <div style="position: fixed;bottom: 90px;justify-content: space-evenly;flex: auto;width: 98%;display: flex;flex-wrap: wrap">
        <template is="dom-repeat" items="[[tableCommands]]">
          <paper-chip on-tap="fireChip" single-line value="[[index]]" style="z-index: 400;">
            <div class="label">[[item]]</div>
          </paper-chip>
        </template>
      </div>
    </div>
    <img on-tap="new" style="position: fixed;bottom: 17px;margin-left: -30px;left: 50%;height: 60px;cursor:pointer;" src="/images/deko.svg" autofocus/>
    <deko-card-container>
      <div></div>
      <div id="tape"></div>
    </deko-card-container>
  </template>
</dom-module>
<script>
  Polymer({
    is: 'deko-cards',
    properties: {
      _setItems: {
        computed: 'setItems(cards, byChild, loadNum, startAt)'
      },
      end: {value: 999},
      find: {value: ''},
      deck: {value: ''},
      pages: {value: []},
      profileId: {value: ''},
      meta: {computed: 'getMeta(profileId)'},
      noAdd: {
        type: Boolean,
        value: false
      },
      editing: {
        type: Boolean,
        value: false
      },
      items: {value: []},
      byChild: {type: String, value: 'added'},
      loadNum: {type: Number, value: 50},
      startAt: {computed: 'getStartAt(pages, find)'},
      pagesLength: {computed: 'getPagesLength(pages)'},
      useTemplates: Object,
      pageing: {
        type: Boolean,
        value: false
      },
      cardPart: {
        observer: 'changingPart',
        value: false
      },
      tricks: {
        value: {
          signedOff: {
            intent: '^((add|with|my) (sign(ed)?([- ]?)off|signature)|qjkxbmwvz)',
            icon: 'assignment-turned-in',
            action: function (signedOff, cb) {
              var stuff = JSON.stringify(signedOff.quill).split(signedOff.replacing)[0] // before sig
              // check if the user has private key

              return db.collection('Users').doc(firebase.auth().currentUser.uid).get().then(function (doc) {
                var data = doc.data()
                if (data.privateKey) {
                  return data
                } else { // if no private key make one
                  return generate(function (key) {
                    db.collection('Users').doc(firebase.auth().currentUser.uid).set({'privateKey': key}, {merge: true})
                  }, function (key) {
                    // public key
                    db.collection('Profiles').where('owner.' + firebase.auth().currentUser.uid, '==', true).get().then(function (Profiles) {
                      Profiles.docs.forEach(function (Profile) {
                        Profile.ref.collection('public key').doc(firebase.auth().currentUser.uid).set({
                          'Public key': key,
                          displayName: firebase.auth().currentUser.displayName
                        })
                      })
                    })
                  })
                }
              }).then(function (keys) {
                return sha256(stuff).then(function (digest) {
                  return sign(digest, keys.privateKey, function (signature) {
                    return [{insert: signature + '\n'}] })
                })
              }).then(function (add) {
                cb(add)
              }).catch(function (e) {
                console.error(e)
              })
            }
          },
          signatures: {
            intent: '^([a-zA-Z0-9+/]{86}==)$',
            signature: '$1', 
            openAction: function (signatures, cb) { 
              var stuff = JSON.stringify(signatures.quill).split(signatures.signature)[0] // before sig 
              this.done[signatures.signature] = true 
              return sha256(stuff).then(function (digest) { 
                if (signatures._) { 
                  var dedup = {} 
                  signatures._.concat([{signature: signatures.signature, stuff: digest}]).forEach(function (sig) { 
                    dedup[sig.signature] = sig.stuff
                  }) 
                  return cb(Object.keys(dedup).map(function (sig) { 
                    return {signature: sig, stuff: dedup[sig]} 
                  })) 
                } else { 
                  return cb([{signature: signatures.signature, stuff: digest}]) 
                } 
              }) 
            },
            action: function (signatures, cb) {
              return false // cb([{insert: signatures.signature + "\n"}])
            },
            html: function (html) {
              var docAsElement = document.createElement("div")
              docAsElement.innerHTML = html
              docAsElement.querySelectorAll("p").forEach(function (p) {
                if (/^([a-zA-Z0-9+/]{86}==)$/g.test(p.innerHTML)) {
                  p.classList.add("signatures")
                }
              }) 
              return docAsElement.innerHTML
            },
            done: {},
          },
          clearUp: {
            html: function (html) {
              var docAsElement = document.createElement("div")
              docAsElement.innerHTML = html
              docAsElement.querySelectorAll("div").forEach(function (div) {
                div.contentEditable="false"
                if (div.className === "ql-clipboard") {
                  div.innerHTML = ""
                }
              })

              return docAsElement.innerHTML.replace('<div class="ql-clipboard" contenteditable="false" tabindex="-1"></div>','').replace('contenteditable="false"' ,'').replace('data-gramm="false"','')
            },
          },
          addImagesTitle: {
            intent: '^add (?:title(?:s)?|synonym(?:s)?) (\\w\\w.+)*',
            words: '$1',
            debounce: 3000,
            action: function (addImagesTitle, cb) {
              var insert = [] // TODO
              console.log(addImagesTitle)
              var image
              var words = addImagesTitle.words.replace('\n', ',').replace('\t', ',').split(',').reduce(function (toSave, word) {
                if (typeof word === 'string') {
                  toSave[word.toLowerCase()] = true
                }
                return toSave
              }, {})

              addImagesTitle.quill.forEach(function (op) {
                if (op.insert && op.insert.image) {
                  image = op.insert.image
                } else if (image && words && typeof op.insert === 'string' && op.insert.indexOf(addImagesTitle.replacing) !== -1) {
                  console.log('save', image, image.split('%2F')[1], words)
                  if (db && image.split('%2F')[1]) {
                    if (addImagesTitle.profileId && words.profile) {
                      db.collection('Profiles').doc(addImagesTitle.profileId).set({image: image}, {merge: true})
                    }
                    return db.collection('files').doc(image.split('%2F')[1]).set({synonyms: words}, {merge: true}).then(function () {
                      insert.push({insert: 'Synonyms added \n'}) // TODO deko Says
                      return cb(insert)
                    })
                  }
                }
              })
            }
          },
          files: {
            intent: '^add (file|document)$',
            ask: ['for files'],
            icon: 'editor:insert-drive-file'
          },
          reminder: {
            intent: '^add reminder$',
            ask: ['for date/time'],
            icon: 'alarm-on'
          },
          timer: {
            intent: '^(add|make|setup a|start) timer (?:for )?([\\d]+) min(?:utes)?$',
            minutes: '$1',
            icon: 'alarm'
          },
          setsReps: {
            sets: '$1',
            reps: '$2',
            weigth: '$3',
            rest: '$4',
            intent: '^(\\d*)s (\\d*)r (\\d*)kg (\\d*)s$',
            icon: 'places:fitness-center',
            html: function (html) {
              var regex = /[\d]+ reps at [\d]+kg(?: done)?|(?:([\d]+)\/)?([\d]+) seconds rest .*/gim
              var docAsElement = document.createElement("div")
              docAsElement.innerHTML = html
              docAsElement.querySelectorAll("p").forEach(function (p) {
                if (regex.test(p.innerHTML)) {
                  p.classList.add("setsreps")
                }
              }) 
              return docAsElement.innerHTML
            },
            action: function (setsReps, cb) {
              var index
              var insert = []

              for (index = 0; index < +setsReps.sets; ++index) {
                insert.push({insert: setsReps.reps + ' reps at ' + setsReps.weigth + 'kg\n'})
                if (index !== (+setsReps.sets) - 1) {
                  insert.push({insert: setsReps.rest + ' seconds rest \n'})
                }
              }

              return cb(insert)
            },
            chips: {
              next: function (quill, showQuill, dataRef, timer, update, save) {
                var that = this
                console.log("running next on ", quill)
                var startTimer
                var movingOn
                var newQuill = new Quill(document.createElement('div'), {})
                newQuill.setContents(quill)

                var ops = []
                function tick () {
                  ops = that.next(ops, showQuill, dataRef, true, update, save)
                  update(ops)
                }

                function moveOn() {
                  ops = that.next(ops, showQuill, dataRef, false, update, save)
                  update(ops)
                }
                if (!timer) {
                  console.log("no timer", quill)
                  clearInterval(this.timer)
                } else if (!that.timer) {
                  that.timer = setInterval(tick, 1000)
                }
                function play (bells) {
                  this.audioDing = document.createElement('audio')
                  this.audioDing.setAttribute('src', 'https://firebasestorage.googleapis.com/v0/b/deko-app-one.appspot.com/o/bell.mp3?alt=media&token=5c83f37c-29d9-4971-aef4-aad504477bbc')
                  this.audioDing.setAttribute('autoplay:false', 'autoplay')
                  if (bells == 1) {
                    this.audioDing.currentTime = 0.8
                  } else if (bells == 2) {
                    this.audioDing.currentTime = 0.4
                  }
                  this.audioDing.play()
                }
                // Look for n reps at n kg
                // set next to heading 3 (first if no set)
                // if n seconds rest n = n - 1 and
                var newQuill = new Quill(document.createElement('div'), {})
                newQuill.setContents(quill)
                var steps = []
                newQuill.getLines().forEach(function (line, idx) {
                  var op = {insert: line.cache.delta.ops[0].insert}
                  var regex = /[\d]+ reps at [\d]+kg$|^(?:([\d]+)\/)?([\d]+) seconds rest $/gm
                  var m
                  if (typeof op.insert === 'string' && (m = regex.exec(op.insert)) !== null) {
                    if (!line.cache.delta.ops[1] || (timer && line.cache.delta.ops[1].attributes && line.cache.delta.ops[1].attributes.header == 2 && +m[1] == m[1])) {
                      steps.push({
                        idx: idx,
                        text: op.insert,
                        line: line
                      })
                      if (steps.length === 1) {
                        if (!line.cache.delta.ops[1]) {
                          op.attributes = {'header': 2}
                        }
                        if (m[1] === undefined && +m[2] && !timer) {
                          // 100 => 0/100 making m[1] == 0
                          op.insert = '0/' + op.insert
                          clearInterval(that.timer)
                          startTimer = true
                        } else if (+m[1] == m[1] && timer) {
                          // 80/100 => 81/100
                          op.insert = ++m[1] + '/' + m[2] + ' seconds rest '
                        } else {
                          // clearInterval(that.timer)
                        }
                        if (10 + m[1] === +m[2] && timer) {
                          play(1)
                        }

                        if (+m[1] === +m[2] && timer) {
                          op.insert = op.insert + ' done \n'
                          if (line.cache.delta.ops[1]) {
                            delete (line.cache.delta.ops[1])
                          }
                          movingOn = true
                        }
                      }
                    } else {
                      op.insert = line.cache.delta.ops[0].insert + ' done \n'
                      if (line.cache.delta.ops[1]) {
                        delete (line.cache.delta.ops[1])
                      }
                      if (line.cache.delta.ops[2]) {
                        delete (line.cache.delta.ops[2])
                      }
                    }
                  }
                  if (idx === 0) {
                    op.attributes = {'header': 1}
                  }
                  ops.push(op)

                  if (line.cache.delta.ops[1]) {
                    ops.push(line.cache.delta.ops[1])
                  }
                  if (line.cache.delta.ops[2]) {
                    ops.push(line.cache.delta.ops[2])
                  }
                })

                // this.tricks.setsReps.timeout = setTimeout(this.tricks.setsReps.chips.next,1000)
                if (window.speechSynthesis && !timer && steps[0] && steps[0].text) {
                  window.speechSynthesis.speak(new SpeechSynthesisUtterance(steps[0].text))
                  save(ops)
                } else if (steps.length === 0) {
                  dataRef.set({setsReps: 'Done'}, {merge: true})
                  save(ops)
                }
                if (startTimer) {
                  setTimeout(function () {
                    tick()
                  },10)
                }
                if (movingOn) {
                  setTimeout(function () {
                    moveOn()
                  },10)
                }

                return ops
              },
            },
          }
        }
      },
      iconTricks: {
        computed: 'getIconTricks(tricks)'
      },
      commands: {
        computed: 'getCommands(cardPart,items)'
      },
      _tableCommands: {
        computed: 'getTableCommands(items)'
      },
      apiURL: {
        value: 'https://us-central1-deko-app-one.cloudfunctions.net/god/'
      },
      _deal: {
        computed: 'deal(cols)'
      } 
    },
    toId: function (i) {
      return i.replace(/[0-9+/\=]/g, '')
    },
    col_1: function(card){
      if (card.place && card.place[this.cols]) {
        return (card.place[this.cols].col === 1)
      } else {
        return true
      }
    }, 
    col_2: function(card){
      return (card.place && card.place[this.cols] && card.place[this.cols].col === 2)
    }, 
    col_3: function(card){
      return (card.place && card.place[this.cols] && card.place[this.cols].col === 3)
    }, 
    col_4: function(card){
      return (card.place && card.place[this.cols] && card.place[this.cols].col === 4)
    }, 
    col_5: function(card){
      return (card.place && card.place[this.cols] && card.place[this.cols].col === 5)
    }, 
    col_6: function(card){
      return (card.place && card.place[this.cols] && card.place[this.cols].col === 6)
    }, 
    sortRow: function(a, b) {
      if (this.cols && a.place && b.place && a.place[this.cols] && b.place[this.cols] ) {
        return a.place[this.cols].row - b.place[this.cols].row
      } else {
        return 1
      }
    },
    deal: function(cols) {
      var elements = document.querySelectorAll('#card-view deko-card')
      var fillCols = {}
      var index = 1
      var cardHeight = 200
      function findNextPlace() {
        if (!fillCols[1] || cols === 1) {return 1}

        if (!fillCols[2]) {return 2}
        if (cols === 2 && fillCols[1].length <= fillCols[2].length) {return 1}
        if (cols === 2) {return 2}

        if (!fillCols[3]) {return 3}
        if (cols === 3 && fillCols[1].length <= fillCols[2].length) {return 1}
        if (cols === 3 && fillCols[2].length <= fillCols[3].length) {return 2}
        if (cols === 3) {return 3}

        if (!fillCols[4]) {return 4}
        if (cols === 4 && fillCols[1].length <= fillCols[2].length) {return 1}
        if (cols === 4 && fillCols[2].length <= fillCols[3].length) {return 2}
        if (cols === 4 && fillCols[3].length <= fillCols[4].length) {return 3}
        if (cols === 4) {return 4}

        if (!fillCols[5]) {return 5}
        if (cols === 5 && fillCols[1].length <= fillCols[2].length) {return 1}
        if (cols === 5 && fillCols[2].length <= fillCols[3].length) {return 2}
        if (cols === 5 && fillCols[3].length <= fillCols[4].length) {return 3}
        if (cols === 5 && fillCols[4].length <= fillCols[5].length) {return 4}
        if (cols === 5) {return 5}

        if (!fillCols[6]) {return 6}
        if (fillCols[1].length <= fillCols[2].length) {return 1}
        if (fillCols[2].length <= fillCols[3].length) {return 2}
        if (fillCols[3].length <= fillCols[4].length) {return 3}
        if (fillCols[4].length <= fillCols[5].length) {return 4}
        if (fillCols[5].length <= fillCols[6].length) {return 5}
        return 6
      }
      Array.from(elements).forEach(function(el){
        var col 
        cardHeight = Math.max(el.offsetHeight, cardHeight) 
        if (el.card.place && el.card.place[cols]) {
          col = +el.card.place[cols].col 
        } else {
          index++
          col = findNextPlace()
          if (!el.card.place) {el.card.place = {}}
          el.card.place[cols] = {row:Math.floor(index % cols), col: col}
        }
        if (!fillCols[col]) {
          fillCols[col] = []
        }
        fillCols[col].push(+el.card.place[cols].row)
        fillCols[col].sort(function(a, b) {return a - b})
        row = fillCols[col].indexOf(+el.card.place[cols].row)
      })

      this.$.list0.render()
      this.$.list1.render()
      this.$.list2.render()
      this.$.list3.render()
      this.$.list4.render()
      this.$.list5.render()
      setTimeout(function() {
        var theCols = document.querySelectorAll('#card-view .col')
        var index = 0
        Array.from(theCols).forEach(function(el){
          index++
          if (fillCols[index] && window.innerHeight < (cardHeight * fillCols[index].length)) {
            el.classList.add("stack")
          } else {
            el.classList.remove("stack")
          }
        })
      },10)
    },
    dropcard: function (e) {
      console.log(e.target.card)
      if (e.dataTransfer.dropEffect === "move") {
        console.log("drop on card")
      }
      var that = this.parentElement.parentElement.parentElement 
      var tape = that.$.tape
      if (tape && tape.offsetWidth) {
        var cols = Math.floor(tape.parentNode.clientWidth / tape.offsetWidth)
        var colWidth = tape.clientWidth
        var leftMargin = (window.innerWidth - tape.parentNode.clientWidth) / 2
        var col = Math.min(cols,Math.max(1,Math.ceil((e.pageX - leftMargin) / colWidth)))
        var row = Math.ceil(e.pageY / 50)
        var place = {row:row, col:col}
        if (e.target.card.ref) {
          var toSave = {}
          toSave.place = {}
          toSave.place[cols]= place
          e.target.card.ref.set(toSave, {merge: true}).then(function () {
            console.log(toSave)
          }).catch(function (e) {
            console.error(e)
          })
        }
        console.log("placing", place)
        if (!e.target.card.place) {
          e.target.card.place = {}
        } 
        e.target.card.place[cols] = place
        setTimeout(function(){
          that.deal(cols)
        },0) 
      }
    },
    clearTrick: function () {
      var that = this
      Object.keys(that.tricks).forEach(function (trick) {
        if (that.tricks[trick].done) {
          that.tricks[trick].done = {}
        }
      })
      Object.keys(that.items[that._items(that.items)]).forEach(function (prop) {
        if (prop.startsWith('_')) {
          delete (that.items[that._items(that.items)][prop])
        }
      })
      that.testStuff(that.tricks, that.quill) // 0 dry
    },
    getMeta: function (profileId) {
      var meta = {}
      meta[profileId] = 'profileId'
      return meta
    },
    imageIndex: function () {
      var that = this
      if (lunr) {
        return db.collection('Profiles').doc(that.profileId).collection('lunr_index').doc('images').get().then(function (doc) {
          return lunr.Index.load(JSON.parse(doc.data().idx))
        }).catch(function(e) {
          console.error(e)
          return 'Error'
        })
      } else {
        console.log(lunr)
        return 'Error'
      }
    },
    fireChip: function (e, d) {
      var that = this
      var chipText = encodeURIComponent(e.currentTarget.innerText.replace('\n', ''))
      if (chipText === 'Getting') {
        that.tableCommands = ['Still Getting']
        return
      }
      if (chipText === 'Still%20Getting') {
        that.tableCommands = []
        return
      }

      this.set('tableCommands', ['Getting'])

      fetch(this.apiURL + 'pik/deko/' + chipText).then(function (response) {
        return response.json()
      }).then(function (response) {
        that.tableCommands = ['Got it']
        if (response.add) {
          response.add.selected = true
          that.set('items', that.items.map(function (x) {
            x.selected = false
            return x
          }).concat([response.add]))

          that.set('editing', true)
          that.set('cardPart', 1)

          that.newCard({
            value: response.add.quill,
            time: +Date.now(), // firebase.database.ServerValue.TIMESTAMP,
            user: firebase.auth().currentUser.uid
          })
        }
      })
    },
    getTableCommands: function (items, selectedItemIndex) {
      if (selectedItemIndex === false) {
        if (items.length === 0) {
        //  this.set("tableCommands",["Welcome,😎 tap here and I'll give you a card"])
          return
        }
      }
      this.set('tableCommands', [])
    },
    getCommands: function (cardPart, items) {
      var selectedCard = this._items(this.items)
      this.showQuill()
      if (cardPart === 0) {
        if (selectedCard !== false && this.items[selectedCard] && this.items[selectedCard].ref) {
          return ['Delete', 'Show it']
        } else {
          return ['Disregard', 'Save']
        }
      } else if (cardPart === 1) {
        this.prompt = ''
        if (selectedCard && this.items[selectedCard].setsReps) {
          return ['Edit', 'Next', 'Give', 'Return' ]
        }
        return ['Edit', 'Give', 'Return']
      } else {
        // get tricks
      }
    },
    showQuill: function (card) {
      
      if (card === undefined) {
        card = this._items(this.items)
      }

      if (card !== false) {
        if (!this.editing && this.quill && this.items[card]  && this.items[card].quill  && this.items[card].quill.length) {
          this.quill.setContents(this.items[card].quill)
        }
      }

      var show = this.$$("#show")
      var setupEditor = false 
      if (show !== null && card !== false && this.items[card].quill && this.items[card].quill.length) {
        var elem
        if (this.$$("#editor")) {
          setupEditor = true
          elem = this.$$("#editor")
        } else {
          elem = document.createElement('div')
        }
        var newQuill = new Quill(elem, {
          modules: {
            toolbar: false
          },
          placeholder: "",
          theme: "bubble",
        })
        newQuill.disable()
        if (!elem.innerText.trim()) {
          newQuill.setContents(this.items[card].quill)
        }
        newQuill.formatLine(1, 2, 'attributes', {header: 1})
        var html = elem.innerHTML
        for (var trick in this.tricks) {
          if (this.tricks[trick].html) {
            html = this.tricks[trick].html(html)
          }
        }
        if (html !== show.innerHTML) {
          this.set(['items',card,'html'], html)
          // update open card
          show.innerHTML = html
          this.set('items', this.items.map(function (x) {
            return x
          }))
        }
        var that = this
        if (setupEditor) {
          newQuill.enable()
          newQuill.on('text-change', function(delta, oldDelta, source) {
            if (source == 'api') {
              console.log("An API call triggered this change.");
            } else if (source == 'user') {
              if (delta.ops && delta.ops[0] && delta.ops[0].retain) {
                that.set("editorCursor", delta.ops[0].retain + 1)
              } else {
                that.set("editorCursor", false)
              }
              that.testStuff(that.tricks, oldDelta.compose(delta).ops)
            }
          })
          this.set("quill", newQuill)
        }
      }
    },
    addTextSetPrompt: function (d) {
      var that = this
      if (this.cardPart == 0) {
        // edit
        this.quill.focus()
        var cur = this.quill.getSelection().index
        var textToAdd = '\n' + d.detail.chip.trim() + ' '
        this.quill.insertText(cur + 1, textToAdd)
        this.quill.setSelection(cur + 1 + textToAdd.length)
        this.line = d.detail.chip.trim() + ' '
        this.chips = []
        this.showQuill()
      } else if (this.cardPart == 1) {
        console.log(d.detail.chip.trim())
        var textOnChip = d.detail.chip.trim().toLowerCase()
        var selectedItem = that._items(this.items)
        function testForFunction (text) { // Returns relevant first trick
          return Object.keys(that.items[selectedItem]).filter(
            function (current) {
              if (current !== 'ref' && that.tricks.hasOwnProperty(current) && that.tricks[current].chips) {
                return that.tricks[current].chips.hasOwnProperty(text)
              } else {
                return false
              }
            }
          )[0]
        }
        if (textOnChip === 'give') {
          that.chips = that.profileList.map(function (profile) {
            return profile.name
          }).filter(function (name) {
            return name
          })
        } else if (testForFunction(textOnChip)) {
          if (typeof that.tricks[testForFunction(textOnChip)].chips[textOnChip] === 'function' && that.items[selectedItem].quill) {
            function update (newQuill) {
              that.set('items.' + selectedItem + '.quill', newQuill)
              that.showQuill()
              that.quill.setContents(newQuill)
            }
            function save(newQuill) {
              var quillSave = {
                value: newQuill,
                time: +Date.now(), // firebase.database.ServerValue.TIMESTAMP,
                user: firebase.auth().currentUser.uid
              }
              if (that.items[selectedItem].ref) {
                that.items[selectedItem].ref.collection('quill').add(quillSave).then(function (data) {
                  that.set('savedQuill', true)
                })
              }
            }
            var newQuill = that.tricks[testForFunction(textOnChip)].chips[textOnChip](that.items[selectedItem].quill, that.showQuill.bind(that), that.items[selectedItem].ref, false, update, save)
            update(newQuill)
            that.showQuill()
          }
        } else if (this.profileList.filter(function (profile) {
          if (profile.name) {
            return profile.name.toLowerCase() === textOnChip
          }
        })[0]) {
          var id = this.profileList.filter(function (profile) {
            if (profile.name) {
              return profile.name.toLowerCase() === textOnChip
            }
          })[0].id

          if (this.items[selectedItem].ref) {
            that.chips = ['giving']
            var given = {}
            given[id] = true
            this.items[selectedItem].ref.set({given: given}, {merge: true}).then(function () {
              that.$$('open-card').close()
              that.chips = []
              if (that.unsub) {
                that.unsub()
              }
              if (that.resub) {
                that.resub()
              }
            }).catch(function (e) {
              console.error(e)
            })
          }
        }
      }
    },
    getIconTricks: function (tricks) {
      return Object.keys(tricks).reduce(function (icons, value) {
        icons.push(tricks[value])
        return icons
      }, [])
    },
    new: function (card) {
      this.set('items', this.items.map(function (x) {
        x.selected = false
        return x
      }).concat([{
        selected: true,
        image: '',
        toolbarColor: undefined,
        html: '<h1>New</h2>',
        quill: [
          {attributes: {header: 1}, insert: '\n'},
          {insert: '\n'},
        ],
        title: ''
      }]))
      this.cardPart = 0
      this.showQuill(this.items[this.items.length - 1])
      this.editing = true
      if (this.unsub) {
        this.unsub()
      }
      var n = 0
      var that = this
      var setFocus
      
      var open = function () {
        if (that.quill && that.$$('open-card') !== null) {
          that.quill.once('text-change', function() {
            try {
              document.body.focus()
              that.quill.focus() 
              clearInterval(setFocus)
            } catch (e) {
              console.error(e)
            }  
          })
          that.quill.setContents([
            {attributes: {header: 1},insert: '\n'},
            {insert: '\n'}
          ])
        }
      }
      
      setTimeout(function(){
        that.$$('open-card').open()
        that.clearTrick()
        setFocus = setInterval(open, 500)
      }, 500)
    },
    newCard: function (toAddQuill) {
      var that = this
      var selectedItem = this._items(this.items)

      var save = {}
      for (var key in this.items[selectedItem]) {
        if (key !== 'quill' && key !== 'selected') {
          save[key] = this.items[selectedItem][key]
        }
      }
      save["added"] = +Date.now()
      if (that.cards.add) {
        that.cards.add(JSON.parse(JSON.stringify(save))).then(function (doc) {
          that.set('items.' + selectedItem + '.ref', doc)
          that.set('loading', false)
          if (toAddQuill) {
            return doc.collection('quill').add(toAddQuill)
          } else {
            console.log("nothing to add")
          }
        }).catch(function (e) {
          console.error('Error adding card: ', e)
        })
      }
    },
    deleteCard: function (e, d) {
      var that = this
      var selectedItem = this._items(this.items)
      if (selectedItem !== false && that.items[selectedItem] && that.items[selectedItem].ref && that.items[selectedItem].ref.id) {
        var deleteId = that.items[selectedItem].ref.id
        that.items[selectedItem].ref.delete().then(function () {
          that.set('items', that.items.reduce(function (accumulator, currentValue) {
            if (that.items[selectedItem] && that.items[selectedItem].ref && that.items[selectedItem].ref.id !== deleteId) {
              accumulator.push(currentValue)
            }
            return accumulator
          }, []))
        }).catch(function (e) {
          console.error('Error removing card: ', e)
        })
      }
      this.resub()
    },
    stuffTest:  async function (data) {
      var that = this
      var selectedItem = that._items(that.items)
      if (selectedItem === false) {
        return
      }
      var elem
    //  if (this.$$("#editor")) {
    //    elem = this.$$("#editor")
    //  } else {
      elem = document.createElement('div')
    //  }
      var newQuill = new Quill(elem, {
        modules: {
          toolbar: false
        },
        placeholder: "",
      })
      
      newQuill.disable()
      if (!that.editing && data && data.docs[0] && data.docs[0].data) {
        newQuill.setContents(data.docs[0].data().value)
      } else if (that.editing && data && Array.isArray(data)) {
        newQuill.setContents(data)
      } else if (!that.editing && that.items[selectedItem].quill) {
        newQuill.setContents(that.items[selectedItem].quill)
      } else if (!that.items[selectedItem].quill && data.docs[0].data().value) {
        that.items[selectedItem].quill = data.docs[0].data().value
        if (!that.editing) {
          newQuill.setContents(that.items[selectedItem].quill)
        }
      } else {
        debugger
      }
      newQuill.formatLine(1, 2, 'attributes', {header: 1}) //not working

      var stuff = newQuill.getContents().ops
      if (JSON.stringify(stuff) == `[{"insert":"\\n"}]`) {
        return 'new'
      }
      var name
      var head
      var headAt
      var image
      var add
      var addAt
      var text = newQuill.getText().replace(/\n/g, ' ').trim()
      var html = elem.innerHTML 
      for (var trick in tricks) {
        if (tricks[trick].html) {
          html = tricks[trick].html(html)
        }
      }      

      function updateCard () {
        if (JSON.stringify(that.items[selectedItem].quill) !== JSON.stringify(stuff)) {
          var quillSave = {
            value: stuff,
            time: Date.now(), // firebase.database.ServerValue.TIMESTAMP,
            user: firebase.auth().currentUser.uid
          }
          if (that.items[selectedItem].ref) {
            that.items[selectedItem].ref.collection('quill').add(quillSave).then(function (data) {
              that.set('savedQuill', true)
            })
          } else {
            that.newCard(quill)
          }

          if (!that.items[selectedItem]) {
            that.items[selectedItem] = {}
          }
          that.set(['items', selectedItem, 'quill'], stuff)
          that.quill.setContents(stuff)
        }
      }
      if (!text) {
        return 'nothing to test'
      }
      if (text.indexOf('order by added') !== -1 && !that.items[selectedItem].ref) {
        that.set("byChild", "added")
      }
      if (text.indexOf('order by title') !== -1 && !that.items[selectedItem].ref) {
        that.set("byChild", "title")
      }
      if (text.indexOf('logout') !== -1 && !that.items[selectedItem].ref) {
        that.fire('logout')
      }
      var title = that.items[selectedItem].title
      if (title) {
        text = text.replace(title, '')
        that.items[selectedItem].autoImage = that.imageIndex().then(function (idx) {
          var result = idx.search(title)
          if (result.length) {
            return '' + result[0].ref
          } else {
            return ''
          }
        })
      }
      if (firebase.storage && that.items[selectedItem].image === '' && that.items[selectedItem].autoImage) {
        that.items[selectedItem].autoImage.then(async function (imageRef) {
          if (!imageRef) {
            return 'no image'
          }
          return firebase.storage().ref().child(imageRef).getDownloadURL().then(function (url) {
            var image = url
            if (image.split('%2F')[1]) { // TODO DRY
              db.collection('files').doc(image.split('%2F')[1]).get().then(function (doc) {
                if (doc.exists && doc.data() && doc.data().vision && doc.data().vision[0].imagePropertiesAnnotation) {
                  var colour = doc.data().vision['0'].imagePropertiesAnnotation.dominantColors.colors['0'].color
                  function componentToHex (c) {
                    var hex = c.toString(16)
                    return hex.length == 1 ? '0' + hex : hex
                  }
                  function rgbToHex (r, g, b) {
                    return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b)
                  }
                  var toolbarColor = rgbToHex(colour.red || 0, colour.green || 0, colour.blue || 0)

                  that.set(['items', selectedItem, 'toolbarColor'], toolbarColor)

                  if (that.items[selectedItem].ref) {
                    that.items[selectedItem].ref.set({toolbarColor: toolbarColor}, {merge: true})
                  }
                }
              })
            }
            if (that.items[selectedItem].ref) {
              that.items[selectedItem].ref.set({image: url}, {merge: true})
            }
            return that.set(['items', selectedItem, 'image'], url)
          })
        })
      }
      if (title && that.items[selectedItem].text !== text) {
        that.items[selectedItem].text = text
        if (that.items[selectedItem].ref) {
          that.items[selectedItem].ref.set({text: text}, {merge: true})
        }
      }
      if (title && that.items[selectedItem].html !== html) {
        for (var trick in that.tricks) {
          if (that.tricks[trick].html) {
            html = that.tricks[trick].html(html)
          }
        }
        that.set(["items",selectedItem,"html"], html)
        if (that.items[selectedItem].ref) {
          that.items[selectedItem].ref.set({html: html}, {merge: true})
        }
      }
      for (var op in stuff) {
        if (stuff[op].insert && typeof stuff[op].insert === 'string') {
          if (!name) {
            name = stuff[op].insert.split('\n')[0]
            if (name) {
              title = name.replace(/[^0-9a-z-A-Z\/ ]/g, ' ').trim()
              if (!title) {
                return 'no title'
              }
              if (that.items[selectedItem].title !== title) {
                that.items[selectedItem].title = title
                that.items[selectedItem].image = '' // new title reset image
                if (that.items[selectedItem].ref) {
                  if (!title) {
                    return 'no title'
                  } else {
                    return that.items[selectedItem].ref.set({title: title}, {merge: true})
                  }
                }
              }
            } else if (stuff[op].insert.split('\n').join('') || (that.items[selectedItem] && !that.items[selectedItem].title)) {
              that.items[selectedItem].title = stuff[op].insert.split('\n').join('')
              if (that.items[selectedItem].ref) {
                that.items[selectedItem].ref.set({title: that.items[selectedItem].title}, {merge: true})
              }
            }
          } else if (!add) {
            var tricks = that.tricks
            var lines = stuff[op].insert.split('\n')
            for (var line in lines) {
              var toAdd = lines[line]
              if (toAdd) {
                for (var trick in tricks) {
                  if (tricks[trick].done && tricks[trick].done[toAdd]) {
                    continue
                  }
                  var regex = new RegExp(tricks[trick].intent, 'gmi')
                  var matchs
                  while ((matchs = regex.exec(toAdd)) !== null && !add) {
                    if (tricks[trick].done && tricks[trick].done[toAdd]) {
                      continue
                    }
                    if (matchs.index === regex.lastIndex) {
                      regex.lastIndex++
                    }
 
                    var addBefore = lines.slice(0, +line).join('\n')
                    addAt = op
                    var addAfter = lines.slice(1 + +(line)).join('\n')
  
                    if (typeof tricks[trick].action === 'function') {
                      var theTrick
 
                      if (!tricks[trick].split) {
                        theTrick = JSON.parse(
                          toAdd.replace(regex, JSON.stringify(tricks[trick])).replace(/(\n|\t)/gm, '\\n')
                        )
                      } else {
                        theTrick = JSON.parse(
                          toAdd.replace(new RegExp(tricks[trick].split, 'gm'), '\\n').replace(regex, JSON.stringify(tricks[trick])).replace(/(\n|\t)/gm, '\\n')
                        )
                      }
                  //  that.set(["items",selectedItem,trick], theTrick)

                      theTrick.quill = stuff
                      theTrick.addBefore = addBefore
                      theTrick.replacing = matchs[0]
                      theTrick.addAfter = addAfter
                      theTrick.profileId = that.profileId
                      theTrick._ = that.items[selectedItem]['_' + trick]

                      if (typeof tricks[trick].openAction === 'function') {
                        await tricks[trick].openAction(theTrick, function (formTrick) {
                          that.set(['items', selectedItem, '_' + trick], formTrick)
                        })
                      }
                      if (tricks[trick].debounce) {
                        if (!tricks[trick].done) {
                          tricks[trick].done = {}
                        }
                        tricks[trick].done[lines[line]] = true // stop loop

                        debounedFunct = function (trik, theTrik) {
                          return function () {
                            trik.action(theTrik, function (formTrick) {
                          // add = [{insert: addBefore + "\n"}].concat(formTrick, [{insert: addAfter + "\n"}])
                          // updateCard()
                          // add = []
                            })
                          }
                        }
                        that.debounce(trick, debounedFunct(tricks[trick], theTrick), tricks[trick].debounce)
                      } else {
                        await tricks[trick].action(theTrick, function (formTrick) {
                          if (formTrick) {
                            add = [{insert: addBefore + '\n'}].concat(formTrick, [{insert: addAfter + '\n'}])
                          }
                        })
                      }
                    } else if (tricks[trick].action) {
                      var theTrick

                      if (!tricks[trick].split) {
                        theTrick = JSON.parse(
                          toAdd.replace(regex, JSON.stringify(tricks[trick])).replace(/(\n|\t)/gm, '\\n')
                        )
                      } else {
                        theTrick = JSON.parse(
                          toAdd.replace(new RegExp(tricks[trick].split, 'gm'), '\\n').replace(regex, JSON.stringify(tricks[trick])).replace(/(\n|\t)/gm, '\\n')
                        )
                      }

                      add = [{insert: addBefore + '\n'}].concat(theTrick.action, [{insert: addAfter + '\n'}])
                      that.set(['items', selectedItem, trick], theTrick)
                    } else {
                      var theTrick = Object.assign({}, tricks[trick])
                   //   add = [
                   //     {insert: addBefore + '\n'},
                   //     {insert: addAfter + '\n'}
                   //   ]
                    }
                    that.set(['items', selectedItem, trick], theTrick)
                    if (that.items[selectedItem].ref) {
                      var toSave = {}
                      var saveTrick = false
                      toSave[trick] = {}
                      Object.keys(theTrick).forEach(function (key) {
                        if (theTrick[key] && !key.startsWith('_') && typeof theTrick[key] !== "function") {
                          toSave[trick][key] = theTrick[key]
                          saveTrick = true
                        }
                      })
                      if (saveTrick) {
                        that.items[selectedItem].ref.set(toSave, {merge: true})
                      }
                    }
                  }
                }
              }
            }
          }
        } else if (!image || that.items[selectedItem].image !== image) {
          if (stuff[op].insert && typeof stuff[op].insert === 'object' && stuff[op].insert.image) {
            image = stuff[op].insert.image
            if (that.items[selectedItem].image !== image) {
              that.set(['items', selectedItem, 'image'], image)
              if (image.split('%2F')[1]) { // TODO DRY
                db.collection('files').doc(image.split('%2F')[1]).get().then(function (doc) {
                  if (doc.exists && doc.data() && doc.data().vision && doc.data().vision[0].imagePropertiesAnnotation) {
                    var colour = doc.data().vision['0'].imagePropertiesAnnotation.dominantColors.colors['0'].color
                    function componentToHex (c) {
                      var hex = c.toString(16)
                      return hex.length == 1 ? '0' + hex : hex
                    }
                    function rgbToHex (r, g, b) {
                      return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b)
                    }
                    var toolbarColor = rgbToHex(colour.red || 0, colour.green || 0, colour.blue || 0)
                    that.set(['items', selectedItem, 'toolbarColor'], toolbarColor)
                    that.items[selectedItem].ref.set({toolbarColor: toolbarColor}, {merge: true})
                  }
                })
              }
              if (that.items[selectedItem].ref) {
                that.items[selectedItem].ref.set({image: image}, {merge: true})
              }
            }
          }
        }
//    if (stuff[op].insert && stuff[op].insert.image) {
//      if (stuff[op].insert.image.length > 1000*1000) {
//        that.resizeImage(stuff, op)
//      }
//    }
      }
      if (head) {
        stuff = stuff.splice(0, +headAt).concat(head, stuff.splice(1 + +(headAt)))
      } else if (add) {
        stuff = stuff.splice(0, +addAt).concat(add, stuff.splice(1 + +(addAt)))
      }
      var cursor = that.editorCursor
      if (add || head) {
        updateCard(that.stuffTest(stuff))
      } else if (cursor) {
        var onLine = that.quill.getLine(cursor)[0].domNode.outerText.replace("\n","").trim()
        if (onLine === "") {
          var line = that.quill.getLine(cursor-1)[0].domNode.outerText.replace("\n","").trim()
          var apiURL = this.apiURL
          if (line && /^[a-z ,]+$/gmi.test(line) && line.length > 5 && line.length < 100 && line.split(' ').length > 1 && line.split(' ').length < 20) {
            console.log(line)
            var dotoQuill = function (response) {
              console.log(response)
              if (response) { 
                // find line  
                // replace text with response
                var cur = cursor - 1
                var onLine = that.quill.getLine(cur)[0].domNode.outerText
                var cur = cur + ((response+" ").length - onLine.length)
                that.quill.setContents(JSON.parse(JSON.stringify(that.quill.getContents()).split(onLine).join(response+" ")))
                that.quill.setSelection(cur)
                that.set("line",response+" ")
              } 
              return response
            }
            if (that.cache && that.cache[line]) {
              dotoQuill(that.cache[line])
            } else {
              this.tricks.signedOff.action({quill:line+"_~_",replacing:"_~_"}, function(sig){
                fetch(`${apiURL}detect/${encodeURIComponent(line)}/${encodeURIComponent(sig[0].insert.replace("\n",''))}`).then(function (response) {
                  return response.json()
                }).then(function(response){
                  if (!that.cache) {
                    that.cache = {}
                  }
                  that.cache[line] = response
                  return response
                }).then(dotoQuill).catch(function(e){
                  console.error(e)
                })
              })
            }
          }
        }
      }
      return stuff
    },
    testStuff: function (tricks, quill) {
      var selected = this._items(this.items)
      if (selected !== false && !this.items[selected].ref) {
        console.log(this.items[selected])
        return
      }
      var that = this
      
      function debouncedTestStuff () {
        var that = this
        async function  save(newQuill) {
          var quillSave = {
            value: await newQuill,
            time: +Date.now(), // firebase.database.ServerValue.TIMESTAMP,
            user: firebase.auth().currentUser.uid
          }
          if (that.items[selectedItem].ref && quillSave.value) {
            that.items[selectedItem].ref.collection('quill').add(quillSave).then(function (data) {
              that.set('savedQuill', true)
            })
          }
        }
        selectedItem = this._items(this.items)
        if (selected !== false && this.items[selected] && this.items[selected].ref) { 
          this.items[selected].ref.collection('quill').orderBy('time', 'desc').limit(1).get().then(that.stuffTest.bind(that)).then(function (quillOps){
            // move card update here
            console.log(quillOps)
            console.log(quill)
            if (Array.isArray(quill) && JSON.stringify(quill) !== JSON.stringify(quillOps)) {
              save(that.stuffTest(quill))
            }
          }).catch(function (e){
            console.log(quill)
            console.error(e)
          })
        }
      }
      this.debounce('debouncedTestStuff', debouncedTestStuff, 2000)
    },
//    resizeImage: function(stuff, opForImage) {
//      var that = this
//      loadImage(
//        stuff[opForImage].insert.image,
//        function (canvas) {
//          if (canvas.toDataURL) {
//            stuff[opForImage].insert.image = canvas.toDataURL()
//            that.set(["items",selectedItem,"quill"], stuff.map(function(x) {return x}) )
//          }
//        }, {
//          canvas: true,
//          maxHeight: 500,
//          maxWidth: 500,
//          orientation: true,
//        }
//      )
//    },
    changingPart: function (part, partFrom) {
      var selectedItem = this._items(this.items)
      this.showQuill(selectedItem)
      var that = this
      var ref
      if (part == 1) {
        this.chips = []
      }
      if (that.items[selectedItem]) {
        ref = that.items[selectedItem].ref
      }
      if (part == 0 && partFrom == 1) {
        if (ref) {
          that.set('loading', true)
          ref.collection('quill').orderBy('time', 'desc').limit(1).get().then(function (data) {
            that.set('loading', false)
            if (data && data.size) {
              var value = data.docs[0].data().value
              if (JSON.stringify(that.items[selectedItem].quill) !== JSON.stringify(value)) {
                that.set(['items', selectedItem, 'quill'], value)
              }
            } else {
//              that.set(["items",selectedItem,"quill"], [{"insert":"\n"}])
            }
          })
        }
      }
      if (part == 1 && partFrom == 0 && this.quill && this.items[selectedItem].quill && JSON.stringify(this.items[selectedItem].quill) != JSON.stringify([{'insert': '\n'}])) {
        var quill = {
          value: this.quill.getContents().ops,
          time: Date.now(), // firebase.database.ServerValue.TIMESTAMP,
          user: firebase.auth().currentUser.uid
        }

        this.items[selectedItem].quill = this.quill.getContents().ops

        if (ref) {
          ref.collection('quill').add(quill).then(function (data) {
            that.set('savedQuill', true)
            that.clearTrick()
          })
        } else {
          that.newCard(quill)
        }
      }
    },
    addToCard: function (cardRef) {
      var selectedItem = this._items(this.items)
      if (selectedItem !== false && this.items[selectedItem].title) {
        var that = this
        cardRef.set({
          title: that.items[selectedItem].title,
          toolbarColor: that.items[selectedItem].toolbarColor
        }, {merge: true}).then(function () {
          that.set(['items', selectedItem], {
            ref: cardRef,
            title: that.items[selectedItem].title,
            toolbarColor: that.items[selectedItem].toolbarColor,
            selected: true
          })
          if (that.items[selectedItem].image) {
            cardRef.collection('image').add({
              value: that.items[selectedItem].image,
              time: Date.now(), // firebase.database.ServerValue.TIMESTAMP,
              user: firebase.auth().currentUser.uid
            }).then()
          }
        })
      }
    },
    getStartAt: function (pages, find) {
      if (find) {
        return find
      } else if (pages.length) {
        return pages[pages.length - 1].start
      } else {
        return ''
      }
    },
    perv: function () {
      this.pages.pop()
      if (this.pages.length) {
        this.find = this.pages[this.pages.length - 1].start
      } else {
        this.find = ''
      }
      this.pages = this.pages.map(function (x) { return x }) // update
      return 1
    },
    next: function () {
      var start = this.nextPageStartAt
      this.find = start
      // var end = this.end
      if (this.pages.length === 0 || start !== this.pages[this.pages.length - 1].start) { // && this.pages.length < end) {
        this.pages.push({
          start: start
        })
        this.pages = this.pages.map(function (x) { return x }) // update

        return 1
      }
      return 0
    },
    getPagesLength: function (pages) {
      return pages.length
    },
    setItems: function (ref, byChild, loadNum, startAt) {
      if (this.editing) {
        return
      }
      var that = this
      function objectToArray (data) {
        var output = []
        if (data) {
          var keys = Object.keys(data)
          for (var i = 0; i < keys.length; i++) {
            if (typeof data[keys[i]] === 'object') {
              data[keys[i]].__key = keys[i]
              output.push(data[keys[i]])
            }
          }
        }
        return output
      }
      function sortByChild (a, b) {
        if (a.hasOwnProperty(byChild) && b.hasOwnProperty(byChild)) {
          var A = a[byChild].toUpperCase()
          var B = b[byChild].toUpperCase()
          if (A < B) { return -1 }
          if (A > B) { return 1 }
        }
        return 0
      }
      var setItems = function (snap) {
        var theSnap = snap.docs
        if (theSnap && !snap.empty) {
          that.set('loaded', theSnap.length)
          // that.items = theSnap.sort(sortByChild)
          var cards = []
          theSnap.forEach(function (doc) {
            var docData = doc.data()
            var html = docData.html
            for (var trick in that.tricks) {
              if (that.tricks[trick].html) {
                html = that.tricks[trick].html(html)
              }
            }
            cards.push({
              title: docData.title || "",
              image: docData.image || "",
              toolbarColor: docData.toolbarColor || "",
              dek: docData.dek || "",
              show: docData.show,
              html: html || "",
              timer: docData.timer,
              reminder: docData.reminder,
              signedOff: docData.signedOff,
              setsReps: docData.setsReps,
              ref: doc.ref,
              added: docData.added,
              weigth: docData.weigth,
              theDate: docData.theDate,
              theLocation: docData.theLocation,
              place: docData.place,
            })
          })
          that.set('editing', false)
          function comp(theCard) {
            var c =  Object.assign({}, theCard)
            if (that.cols && c.place) {
              c.placeCols = c.place[that.cols]
              delete(c.place)
            }
            delete(c.ref)
            return c
          } 
          if (!that.items) {
            that.set('items', cards)
          } else if (JSON.stringify(that.items.map(comp)) !== JSON.stringify(cards.map(comp))) {
            that.set('items', cards)
          }
          console.log(that.items)
          setTimeout(function(){
            that.deal(that.cols)
          },250) 
          if (that.loaded == +loadNum) {
            if (that.items[+loadNum - 1][byChild]) {
              that.nextPageStartAt = that.items[+loadNum - 1][byChild] + '~'
            } else {
              that.nextPageStartAt = 'A'
            }
          } else {
            that.nextPageStartAt = null
            that.end = 1 + that.pagesLength
          }
        } else {
          that.nextPageStartAt = null
          that.end = 1 + that.pagesLength
          that.items = []
        }
      }
      var listRef
      if (byChild === '__key') {
        listRef = ref
      } else {
        listRef = ref.orderBy(byChild)
      }
      if (this.unsub) {
        this.unsub()
      }
      if (startAt) {
        this.unsub = listRef.startAt(startAt).limit(+loadNum).onSnapshot(setItems)
      } else {
        this.unsub = listRef.limit(+loadNum).onSnapshot(setItems) // TODO
      }
    },
    open: function (e, d) {
      if (this.unsub) {
        this.unsub()
      }
      this.clearTrick()
      this.editing = true
      this.fire('open-card', {e: e, d: d})
    },
    pickable: function (item) {
      return !item.selected
    },
    selected: function (item) {
      return item.selected || false
    },
    reduceToIndexOfSelected: function (accumulator, card, currentIndex) {
      if (card.selected) {
        accumulator = currentIndex
      }
      return accumulator
    },
    select: function (e) {
      var pick
      var toReturn
      if (pick = e.target.parentNode.parentNode.parentNode.parentNode.parentNode.card) {
        toReturn = e.target.parentNode.parentNode.parentNode.parentNode.parentNode
      } else if (pick = e.target.parentNode.parentNode.parentNode.parentNode.card){
        toReturn = e.target.parentNode.parentNode.parentNode.parentNode
      } else if (pick = e.target.parentNode.parentNode.parentNode.card){
        toReturn = e.target.parentNode.parentNode.parentNode
      } else if (pick = e.target.parentNode.parentNode.card){
        toReturn = e.target.parentNode.parentNode
      } else if (pick = e.target.parentNode.card){          
        toReturn = e.target.parentNode
      } else if (pick = e.target.card){     
        toReturn = e.target
      }
      var that = this

      var id = ''

      if (pick.ref) {
        id = pick.ref.id
        pick.ref.collection('quill').orderBy('time', 'desc').limit(1).get().then(function (data) {
          if (data && data.size) {
            var value = data.docs[0].data().value
            var selectedItem = that._items(that.items)
            that.set('items.' + selectedItem + '.quill', value)
          } else {
            that.set('items.' + selectedItem + '.quill', [{'insert': '\n'}])
          }
        })
      }
      
      this.items = this.items.map(function (x, i) {
        if (x.ref && x.ref.id === id) {
          x.selected = true
        } else {
          x.selected = false
        }
        return x
      })

      return toReturn
    },
    selectOpen: function (e,d) {
      // if focus :
    //  this.clearTrick() l/l/l/l/l/l/l/l/l/l/l/l/l/l/l/ TODO:
      var cardEle
      if (document.activeElement.card && document.activeElement.card.selected) {
        this.cardPart = 1
        this.$.opencard.render()
        this.$$('open-card').open()
        if (this.unsub) {
          this.unsub()
        }
        this.editing = true
      } else if (document.activeElement.card) {
        cardEle = this.select(e)
        cardEle.setAttribute("draggable", true)
        cardEle.ondragend = this.dropcard
      }
    },
    resub: function (e) {
      this.editing = false
      this.setItems(this.cards, this.byChild, this.loadNum, this.startAt)
    },
    _items: function (items) {
      if (items && items !== null && items.length) {
        return this.items.reduce(this.reduceToIndexOfSelected, false)
      }
      return false
    },
    getFg: function (bg) {
      if (bg) {
        if (bg.length === 4) {
          bg = "#" + bg.charAt(1) + bg.charAt(1) + bg.charAt(2) + bg.charAt(2) + bg.charAt(3) + bg.charAt(3)
        }
        var c = bg.substring(1)     // strip #
        var rgb = parseInt(c, 16)   // convert rrggbb to decimal
        var r = (rgb >> 16) & 0xff  // extract red
        var g = (rgb >> 8) & 0xff  // extract green
        var b = (rgb >> 0) & 0xff  // extract blue
        var luma = 0.2126 * r + 0.7152 * g + 0.0722 * b // per ITU-R BT.709
        if (luma > 128) {
          return '#000'
        } else {
          return '#FFF'
        }
      } else {
        return '#000'
      }
    },
    ready: function () {
      var that = this
      fetch(this.apiURL + 'profiles').then(function (response) {
        return response.json()
      }).then(function (response) {
        that.profileList = response
      })
      var _cols_ = function () {
        var tape = that.$.tape
        if (tape && tape.offsetWidth) {
          var cols =  Math.floor((tape.parentNode.clientWidth / tape.offsetWidth ))
          if (that.cols !== cols) {
            that.set("cols", cols)
          }
        }
      }
      setTimeout(_cols_,500)
      window.addEventListener('resize', _cols_ )
    },
  })

  function importKey (KeyAsJson, cb) {
    var key = JSON.parse(KeyAsJson)
    var hard = key.hard ? new RegExp(key.hard, 'g') : ''

    return window.crypto.subtle.importKey('jwk', key, {name: 'ECDSA', namedCurve: 'P-256'}, false, key.key_ops).then(function (key) {
      return cb(key, hard)
    }).then(function (ret) {
      return ret
    }).catch(function (e) {
      console.error(e)
    })
  }
  function ab2str (buf) {
    return String.fromCharCode.apply(null, new Uint16Array(buf))
  }
  function str2ab (str) {
    var buf = new ArrayBuffer(str.length * 2) // 2 bytes for each char
    var bufView = new Uint16Array(buf)
    for (var i = 0, strLen = str.length; i < strLen; i++) {
      bufView[i] = str.charCodeAt(i)
    }
    return buf
  }
  function arrayToBase64String (ab) {
    var dView = new Uint8Array(ab)   // Get a byte view
    var arr = Array.prototype.slice.call(dView) // Create a normal array
    var arr1 = arr.map(function (item) {
      return String.fromCharCode(item)    // Convert
    })
    return window.btoa(arr1.join(''))  // Form a string
  }

  function base64ToArrayBuffer (s) {
    var asciiString = window.atob(s)
    return new Uint8Array([...asciiString].map(char => char.charCodeAt(0)))
  }

// sign takes a string to be signed and a private key and a call back which is fired with the argument of the signature
  function sign (string, privateKey, cb) {
    var data = str2ab(string)

    return importKey(privateKey, function (key, regx) {
      if (!regx) {
        return window.crypto.subtle.sign({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, data).then(function (signature) {
          return cb(arrayToBase64String(signature))
        }).catch(function (e) {
          console.error(e)
        })
      } else {
        var doWork = function () {
          var work = window.crypto.subtle.sign({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, data)
          return work.then(function (signature) {
            var sig = arrayToBase64String(signature)
            if (regx.test(sig)) {
              return cb(sig)
            } else {
              return doWork()
            }
          })
        }
        return doWork()
      }
    })
  }

  function exportKey (Key, cb) {
    return window.crypto.subtle.exportKey('jwk', Key).then(function (keydata) {
    // returns the exported key data
      var key = JSON.stringify(keydata)
      cb(key)
      return key
    }).then(function (key) {
      return key
    }).catch(function (err) {
      console.error(err)
    })
  }
// this function takes callbacks private key and public key and return {privateKey: "{...}",publicKey: "{...}"}
  function generate (privateKeyCB, publicKeyCB) {
    var keys = {}
    return window.crypto.subtle.generateKey({ name: 'ECDSA', namedCurve: 'P-256'}, true, ['sign', 'verify']).then(function (key) {
      return exportKey(key.privateKey, privateKeyCB).then(function (privateKey) {
        keys.privateKey = privateKey
        return exportKey(key.publicKey, publicKeyCB).then(function (publicKey) {
          keys.publicKey = publicKey
        })
      }).then(function () {
        return keys
      })
    }).catch(function (e) {
      console.error(e)
    })
  }
  function verify (string, signature, publicKey, cb) {
    var data = str2ab(string)
    importKey(publicKey, function (key) {
      window.crypto.subtle.verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, base64ToArrayBuffer(signature), data).then(function (isvalid) {
      // returns a boolean on whether the signature is true or not
        cb(isvalid)
      }).catch(function (e) {
        console.error(e)
      })
    })
  }
  function sha256 (str) {
  // We transform the string into an arraybuffer.
    var buffer = new TextEncoder('utf-8').encode(str)
    return crypto.subtle.digest('SHA-256', buffer).then(function (hash) {
      return hex(hash)
    })
  }

  function hex (buffer) {
    var hexCodes = []
    var view = new DataView(buffer)
    for (var i = 0; i < view.byteLength; i += 4) {
    // Using getUint32 reduces the number of iterations needed (we process 4 bytes each time)
      var value = view.getUint32(i)
    // toString(16) will give the hex representation of the number without padding
      var stringValue = value.toString(16)
    // We use concatenation and slice for padding
      var padding = '00000000'
      var paddedValue = (padding + stringValue).slice(-padding.length)
      hexCodes.push(paddedValue)
    }

  // Join all the hex strings into one
    return hexCodes.join('')
  }
  function dragover_handler(ev) {
    ev.preventDefault();
    // Set the dropEffect to move
    ev.dataTransfer.dropEffect = "move"
  }
</script>
